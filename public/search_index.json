[
["index.html", "Se former au logiciel R : initiation et perfectionnement 1 Préambule", " Se former au logiciel R : initiation et perfectionnement François Rebaudo 2018-10-18 1 Préambule Ce livre est incomplet pour le moment et vous visualisez sa version préliminaire. De nombreux chapitres sont néanmoins déjà en ligne, alors n’hésitez pas à les consulter et à commencer votre formation ou votre perfectionnement au langage de programmation R. Si vous avez des commentaires, des suggestions ou si vous identifiez des erreurs, n’hésitez pas à m’envoyer un email (francois.rebaudo@ird.fr), ou si vous connaissez GitHub sur le site du projet (https://github.com/frareb/myRBook_FR). Ce livre est collaboratif, il repose sur votre participation. Ce livre est également disponible en espagnol (http://myrbooksp.netlify.com/). Dernières modifications: 18/10/2018 algorithmique La boucle “while” (4/6) algorithmique La boucle “repeat” (4’/6) 28/09/2018 algorithmique Tests logiques avec “switch” (2/6) algorithmique La boucle “for” (3/6) 17/09/2018 algorithmique Tests logiques avec “if” (1/6) 10/09/2018 nouveau chapitre Importer et exporter des données 30/08/2018 Modifications de Marc G. (étude de cas ; types de données) nouvelle étude de cas : analyse des données de datalogger de température 24/08/2018 Les fonctions (partie 2/3 et 3/3) : écrire une fonction et conclusion 27/07/2018 Etude de cas : Obtenir le numéro WOS d’un article scientifique à partir de son numéro DOI typos et références internes 25/07/2018 Les fonctions (partie 1/3) : les fonctions les plus courantes 17/07/2018 Les conteneurs de données (partie 4/5) : matrix Les conteneurs de données (partie 5/5) : array 13/07/2018 mise en ligne du contenu en français sur la base du livre en espagnol Les conteneurs de données (partie 3/5) : data.frame "],
["remerciements.html", " 2 Remerciements", " 2 Remerciements Je remercie tous les contributeurs qui ont participé à améliorer ce livre par leurs conseils, leurs suggestions de modifications et leurs corrections (par ordre alphabétique) : ## Contributeurs : Camila Benavides Frias (Bolivia) Marc Girondot (France ; UMR 8079 ESE) Susi Loza Herrera (Bolivia) Estefania Quenta Herrera (Bolivia) Les versions gitbook, html et epub de ce livre utilisent les icônes open source de Font Awesome (https://fontawesome.com). La version PDF utilise les icônes issues du projet Tango disponibles depuis openclipart (https://openclipart.org/). Ce livre a été écrit avec le package R bookdown (https://bookdown.org/). Le code source est disponible sur GitHub (https://github.com/frareb/myRBook_FR). La compilation en gitbook utilise Travis CI (https://travis-ci.org). La version en ligne est hébergée et mise à jour grâce à Netlify (http://myrbookfr.netlify.com/). "],
["licence.html", " 3 Licence", " 3 Licence Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Pas de Modification 3.0 France (CC BY-NC-ND 3.0 FR ; https://creativecommons.org/licenses/by-nc-nd/3.0/fr/) C’est un résumé (et non pas un substitut) de la licence. Vous êtes autorisé à : Partager — copier, distribuer et communiquer le matériel par tous moyens et sous tous formats. L’Offrant ne peut retirer les autorisations concédées par la licence tant que vous appliquez les termes de cette licence. Selon les conditions suivantes : Attribution — Vous devez créditer l’Œuvre, intégrer un lien vers la licence et indiquer si des modifications ont été effectuées à l’Oeuvre. Vous devez indiquer ces informations par tous les moyens raisonnables, sans toutefois suggérer que l’Offrant vous soutient ou soutient la façon dont vous avez utilisé son Oeuvre. Pas d’Utilisation Commerciale — Vous n’êtes pas autorisé à faire un usage commercial de cette Oeuvre, tout ou partie du matériel la composant. Pas de modifications — Dans le cas où vous effectuez un remix, que vous transformez, ou créez à partir du matériel composant l’Oeuvre originale, vous n’êtes pas autorisé à distribuer ou mettre à disposition l’Oeuvre modifiée. Pas de restrictions complémentaires — Vous n’êtes pas autorisé à appliquer des conditions légales ou des mesures techniques qui restreindraient légalement autrui à utiliser l’Oeuvre dans les conditions décrites par la licence. Notes : Vous n’êtes pas dans l’obligation de respecter la licence pour les éléments ou matériel appartenant au domaine public ou dans le cas où l’utilisation que vous souhaitez faire est couverte par une exception. Aucune garantie n’est donnée. Il se peut que la licence ne vous donne pas toutes les permissions nécessaires pour votre utilisation. Par exemple, certains droits comme les droits moraux, le droit des données personnelles et le droit à l’image sont susceptibles de limiter votre utilisation. "],
["intro.html", " 4 Introduction 4.1 Pourquoi se former à R 4.2 Ce livre 4.3 Lectures complémentaires en français", " 4 Introduction 4.1 Pourquoi se former à R Parce que R s’est imposé comme un incontournable outil pour l’analyse et la gestion des données scientifiques, et qu’il devient dans ce contexte indispensable d’en maîtriser à minima les bases. Le succès de R n’est pas un hasard : R est un logiciel que tout le monde peut se procurer librement assurant ainsi la transparence et la reproductibilité des résultats scientifiques (sous réserve de respecter quelques règles que ce livre abordera). R repose aussi sur une communauté très active avec plusieurs milliers de modules complémentaires (packages) pour effectuer les analyses statistiques les plus pointues. 4.2 Ce livre L’objectif de ce livre est de fournir aux étudiants et aux personnes souhaitant s’initier à R une base solide pour ensuite mettre en oeuvre leurs propres projets scientifiques et la valorisation de leurs résultats. Il existe de nombreux livres dédiés à R, mais aucun ne couvre les éléments de base de ce langage dans un objectif de rendre les résultats scientifiques publiables et reproductibles. De manière générale ce livre s’adresse à toute la communauté scientifique et en particulier à celle intéressée par les sciences du vivant, et les nombreux exemples de ce livre s’appuieront sur des études en biologie. Ce livre est né de la demande des étudiants des universités partenaires de l’IRD en Amérique du Sud que j’ai eu la chance de rencontrer et de former à R. Sa première version est donc rédigée en espagnol (il existe peu de documents de qualité sur R en espagnol). J’ai entamé sa traduction en français courant 2018 et aujourd’hui les deux versions coévoluent avec des contenus qui peuvent varier (par exemple pour les études de cas). 4.3 Lectures complémentaires en français R pour les débutants, Emmanuel Paradis (https://cran.r-project.org/doc/contrib/Paradis-rdebuts_fr.pdf) Introduction à la programmation avec R, Vincent Goulet (https://cran.r-project.org/doc/contrib/Goulet_introduction_programmation_R.pdf) "],
["premiersPas.html", " 5 Premiers pas 5.1 Installation de R 5.2 R comme calculatrice 5.3 La notion d’objet 5.4 Les scripts 5.5 Conclusion", " 5 Premiers pas 5.1 Installation de R Le programme permettant l’installation du logiciel R peut être téléchargé depuis le site web de R : https://www.r-project.org/. Sur le site de R il faut au préalable choisir un mirroir CRAN (serveur depuis lequel télécharger R ; sauf cas particulier le plus proche de sa localisation géographique), puis télécharger le fichier base. Les utilisateurs de Linux pourront préférer un sudo apt-get install r-base. Le logiciel R peut être téléchargé depuis de nombreux serveurs du CRAN (Comprehensive R Archive Network) à travers le monde. Ces serveurs s’appellent des miroirs. Le choix du miroir est manuel. Les informations complémentaires comme cette note seront toujours représentées avec ce pictogramme information. 5.2 R comme calculatrice Une fois le programme lancé, une fenêtre apparaît dont l’aspect peut varier en fonction de votre système d’exploitation (Figure 5.1). Cette fenêtre est dénommée la console. Figure 5.1: Capture d’écran de la console R sous Windows. La console correspond à l’interface où va être interprété le code, c’est à dire à l’endroit où le code va être transformé en langage machine, éxécuter par l’ordinateur, puis retransmis sous une forme lisible par des humains. Cela correspond à l’écran d’affichage d’une calculatrice (Figure 5.2). C’est de cette manière que R va être utilisé dans la suite de cette section. Tout au long de ce livre, les exemples de code R apparaîtront sur fond en gris. Ils peuvent être copiés et collés directement dans la console, bien qu’il soit préférable de reproduire soit même les exemples dans la console (ou plus tard dans les scripts). Le résultat de ce qui est envoyé dans la console apparaîtra également sur fond en gris avec ## devant le code afin de bien faire la distinction entre le code et le résultat du code. Figure 5.2: Capture d’écran de la console R sous Windows avec la calculatrice Windows. 5.2.1 Les opérateurs arithmétiques 5 + 5 ## [1] 10 Si nous écrivons 5 + 5 dans la console puis Entrée, le résultat apparaît précédé du chiffre [1] entre crochets. Ce chiffre correspond au numéro du résultat (dans notre cas, il n’y a qu’un seul résultat ; nous reviendrons sur cet aspect plus tard). Nous pouvons également noter dans cet exemple l’utilisation d’espaces avant et après le signe +. Ces espaces ne sont pas nécessaires mais permettent au code d’être plus lisible par les humains (i.e., plus agréable à lire pour nous comme pour les personnes avec qui nous serons amenés à partager notre code). Les opérateurs aritmétiques disponibles sous R sont résumés dans la table 5.1. Table 5.1: Opérateurs arithmétiques. Label Operateur Addition + Soustraction - Multiplication * Division / Puissance ^ Modulo %% Quotien Décimal %/% Classiquement, les multiplications et les divisions sont prioritaires sur les additions et les soustractions. Au besoin nous pouvons utiliser des parenthèses. 5 + 5 * 2 ## [1] 15 (5 + 5) * 2 ## [1] 20 L’opérateur modulo correspond au reste de la division euclidienne. Il est souvent utilisé en informatique par exemple pour savoir si un nombre est pair ou impair (un nombre modulo 2 va renvoyer 1 si il est impair et 0 si il est pair). 451 %% 2 ## [1] 1 288 %% 2 ## [1] 0 (5 + 5 * 2) %% 2 ## [1] 1 ((5 + 5) * 2) %% 2 ## [1] 0 R intègre également certaines constantes dont pi. Par ailleurs le signe infini est représenté par Inf pi ## [1] 3.141593 pi * 5^2 ## [1] 78.53982 1/0 ## [1] Inf le style du code est important car le code est destiné à être lisible par nous plus tard et par d’autres personnes de manière générale. Pour avoir un style lisible il est recommandé de mettre des espaces avant et après les opérateurs arithmétiques. Les informations concernant le style seront toujours représentées avec ce pictogramme afin qu’elles soient facilement identifiables. 5.2.2 Les opérateurs de comparaison R est cependant bien plus qu’une simple calculatrice puisque’il permet un autre type d’opérateurs : les opérateurs de comparaison. Ils servent comme leur nom l’indique à comparer des valeurs entre elles (Table 5.2). Table 5.2: Opérateurs de comparaison. Label Operador plus petit que &lt; plus grand que &gt; plus petit ou égal à &lt;= plus grand ou égal à &gt;= égal à == différent de != Par exemple si nous voulons savoir si un chiffre est plus grand qu’un autre, nous pouvons écrire : 5 &gt; 3 ## [1] TRUE R renvoie la valeur TRUE si la comparasion est vraie et FALSE si la comparaison est fausse. 5 &gt; 3 ## [1] TRUE 2 &lt; 1.5 ## [1] FALSE 2 &lt;= 2 ## [1] TRUE 3.2 &gt;= 1.5 ## [1] TRUE Nous pouvons combiner les opérateurs arithmétiques avec les opérateurs de comparasion. (5 + 8) &gt; (3 * 45/2) ## [1] FALSE Dans la comparasion (5 + 8) &gt; (3 * 45/2) les parenthèses ne sont pas nécessaires mais elles permettent au code d’être plus facile à lire. Un opérateur de comparaison particulier est égal à. Nous verrons dans la section suivante que le signe = est réservé à un autre usage : il permet d’affecter une valeur à un objet. L’opérateur de comparaison égal à doit donc être différent, c’est pour cela que R utilise ==. 42 == 53 ## [1] FALSE 58 == 58 ## [1] TRUE Un autre opérateur particulier est différent de. Il est utilisé avec un point d’intérrogation suivi de égal, !=. Cet opérateur permet de d’obtenir la réponse inverse à ==. 42 == 53 ## [1] FALSE 42 != 53 ## [1] TRUE (3 + 2) != 5 ## [1] FALSE 10/2 == 5 ## [1] TRUE R utilise TRUE et FALSE qui sont aussi des valeurs qui peuvent être testées avec les opérateurs de comparasion. Mais R attribue également une valeur à TRUE et FALSE : TRUE == TRUE ## [1] TRUE TRUE &gt; FALSE ## [1] TRUE 1 == TRUE ## [1] TRUE 0 == FALSE ## [1] TRUE TRUE + 1 ## [1] 2 FALSE + 1 ## [1] 1 (FALSE + 1) == TRUE ## [1] TRUE La valeur de TRUE est de 1 et la valeur de FALSE est de 0. Nous verrons plus tard comment utiliser cette information dans les prochains chapitres. R est aussi un langage relativement permissif, cela veut dire qu’il admet une certaine flexibilité dans la manière de rédiger le code. Débattre du bien fondé de cette flexibilité sort du cadre de ce livre mais nous pourrons trouver dans du code R sur Internet ou dans d’autres ouvrages le raccourcis T pour TRUE et F pour FALSE. T == TRUE ## [1] TRUE F == FALSE ## [1] TRUE T == 1 ## [1] TRUE F == 0 ## [1] TRUE (F + 1) == TRUE ## [1] TRUE Bien que cette façon de se référer à TRUE et FALSE par T et F soit assez répandue, dans ce livre nous utiliserons toujours TRUE et FALSE afin que le code soit plus facile à lire. Encore une fois l’objectif d’un code est de non seuleument être fonctionnel mais aussi d’être facile à lire et à relire. 5.2.3 Les opérateurs logiques Il existe un dernier type d’opérateur, les opérateurs logiques. Ils sont utiles pour combiner des opérateurs de comparaison (Table 5.3). Table 5.3: Opérateurs logiques. Label Operador n’est pas ! et &amp; ou | ou exclusif xor() !TRUE ## [1] FALSE !FALSE ## [1] TRUE ((3 + 2) == 5) &amp; ((3 + 3) == 5) ## [1] FALSE ((3 + 2) == 5) &amp; ((3 + 3) == 6) ## [1] TRUE (3 &lt; 5) &amp; (5 &lt; 5) ## [1] FALSE (3 &lt; 5) &amp; (5 &lt;= 5) ## [1] TRUE L’opérateur logique xor() correspond à un ou exclusif. C’est à dire que l’un des deux arguments de la fonction xor() doit être vrai, mais pas les deux. Nous reviendrons plus tard sur les fonctions et leurs arguments, mais retenons que l’on identifie une fonction par ses parenthèses qui contiennent des arguments séparés par des virgules. xor((3 + 2) == 5, (3 + 3) == 6) ## [1] FALSE xor((3 + 2) == 5, (3 + 2) == 6) ## [1] TRUE xor((3 + 3) == 5, (3 + 2) == 6) ## [1] FALSE xor((3 + 3) == 5, (3 + 3) == 6) ## [1] TRUE Il est recommandé que les virgules , soient suivies par un espace afin que le code soit plus agréable à lire. 5.2.4 Aide sur les opérateurs Le fichier d’aideen anglais sur les opérateurs arithmétiques peut être obtenue avec la commande ?'+' celui sur les opérateurs de comparaison avec la commande ?'==' et celui sur les opérateurs logiques avec la commande ?'&amp;'. 5.3 La notion d’objet Un aspect important de la programmation avec R, mais aussi de la programmation en général est la notion d’objet. Comme indiqué sur la page web de wikipedia (https://fr.wikipedia.org/wiki/Objet_(informatique)), en informatique, un objet est un conteneur, c’est à dire quelque chose qui va contenir de l’information. L’inforamtion contenue dans un objet peut être très diverse, mais pour le moment nous allons contenir dans un objet le chiffre 5. Pour ce faire (et pour pouvoir le réutiliser par la suite), il nous faut donner un nom à notre objet. Avec R le nom des objets ne doit pas comprendre de caractères spéciaux comme ^$?|+()[]}{, ne doit pas commencer par un chiffre ni contenir d’espaces. Le nom de l’objet doit être représentatif de ce qu’il contient, tout en étant ni trop court ni trop long. Imaginons que notre chiffre 5 corresponde au nombre de répétitions d’une expérience. Nous voudrions lui donner un nom faisant référence à nombre et à répétition, que nous pourrions réduire à nbr et rep, respectivement. Il existe plusieurs possibilités qui sont toutes assez répandues sous R : la séparation au moyen du caractère tiret bas : nbr_rep la séparation au moyen du caractère point : nbr.rep l’utilisation de lettres minuscules : nbrrep le style lowerCamelCase consistant en un premier mot en minuscules et des suivants avec une majuscule : nbrRep le style UpperCamelCase consistant à mettre une majuscule au début de chacun des mots : NbrRep Toutes ces formes de nommer un objet sont équivalentes. Dans ce livre nous utiliserons le style lowerCamelCase. De manière générale il faut éviter les noms trop longs comme leNombreDeRepetitions ou trop courts comme nR, et les noms ne permettant pas d’identifier le contenu comme maVariable ou monChiffre, mais aussi a ou b… Il existe différentes façons de définir un nom pour les objets que nous allons créer avec R. Dans ce livre il est utilisé le style lowerCamelCase. L’important n’est pas le choix du style mais la consistence dans son choix. L’objectif est d’avoir un code fonctionnel mais également un code facile et agréable à lire. Maintenant que nous avons choisi un nom pour notre objet, il faut le créer et faire comprendre à R que notre objet doit contenir le chiffre 5. Il existe trois façons de créer un objet sous R: avec le signe &lt;- avec le signe = avec le signe -&gt; nbrRep &lt;- 5 nbrRep = 5 5 -&gt; nbrRep Dans ce livre nous utiliserons toujours la forme &lt;- par souci de consistence et aussi parce que c’est la forme la plus répendue. nbrRep &lt;- 5 Nous venons de créer un objet nbrRep et de lui affecter la valeur 5. Cet objet est désormais disponible dans notre environnement de calcul et peut donc être utilisé. Voici quelques exemples : nbrRep + 2 ## [1] 7 nbrRep * 5 - 45/56 ## [1] 24.19643 pi * nbrRep^2 ## [1] 78.53982 La valeur associée à notre objet nbrRep peut être modifiée de la même manière que lors de sa création : nbrRep &lt;- 5 nbrRep + 2 ## [1] 7 nbrRep &lt;- 10 nbrRep + 2 ## [1] 12 nbrRep &lt;- 5 * 2 + 7/3 nbrRep + 2 ## [1] 14.33333 L’utilisation des objets prend tout son sens lorsque nous avons des opérations complexes à réaliser et rend le code plus agréable à lire et à comprendre. (5 + 9^2 - 1/18) / (32 * 45/8 + 3) ## [1] 0.4696418 terme01 &lt;- 5 + 9^2 - 1/18 terme02 &lt;- 32 * 45/8 + 3 terme01 / terme02 ## [1] 0.4696418 5.4 Les scripts R est un langage de programmation souvent dénommé langage de script. Cela fait référence au fait que la plupart des utilisateurs vont écrire des petits bouts de code plutôt que des programmes entiers. R peut être utilisé comme une simple calculatrice, et dans ce cas il ne sera pas nécessaire de conserver un historique des opérations qui ont été réalisées. Mais si les opérations à réliser sont longues et complexes, il peut devenir nécessaire de pouvoir sauvegarder ce qui a été fait à un moment donné pour pouvoir poursuivre plus tard. Le fichier dans lequel seront conservées les opérations consitue ce que l’on appelle communement le script. Un script est donc un fichier contenant une succession d’informations compréhensibles par R et qu’il est possible d’éxécuter. 5.4.1 Créer un script et le documenter Pour ouvrir un nouveau script il suffit de créer un fichier texte vide qui sera édité par un éditeur de texte comme le bloc note sous Windows ou Mac OS, ou encore Gedit ou même nano sous Linux. Par convention ce fichier prend l’extension “.r” ou plus souvent “.R”. C’est cette dernière convention qui sera utilisée dans ce livre. Depuis l’interface graphique de R il est possible de créer un nouveux script sous Mac OS et Windows via fichier puis nouveau script et enregistrer sous. Tout comme le nom des objets, le nom du script est important pour que nous puissions facilement identifier son contenu. Par exemple nous pourrions créer un fichier formRConceptsBase.R contenant les objets que nous venons de créer et les calculs effectués. Mais même avec des noms de variables et un nom de fichier bien définis, il sera difficile de se rappeler le sens de cce fichier sans une documentation accompagnant ce script. Pour docummenter un script nous allons utiliser des commentaires. Les commentaires sont des éléments qui seront identifiés par R comme tel et qui ne seront pas éxécutés. Pour spécifier à R que nous allons faire un commentaire, il faut utiliser le caractère octothorpe (croisillon) #. Les commentaires peuvent être insérés sur une nouvelle ligne ou en fin de ligne. # creation objet nombre de repetitions nbrRep &lt;- 5 # commentaire de fin de ligne Les commentaires peuvent aussi être utilisé pour qu’une ligne ne soit plus éxécutée. nbrRep &lt;- 5 # nbrRep + 5 Pour en revenir à la documentation du script, il est recommandé de commencer chacun de ses scripts par une brève description de son contenu, puis lorsque le script devient long, de le structurer en différentes parties pour faciliter sa lecture. # ------------------------------------------------------------ # Voici un script pour acquérir les concepts de base # avec R # date de création : 25/06/2018 # auteur : François Rebaudo # ------------------------------------------------------------ # [1] création de l&#39;objet nombre de répétitions # ------------------------------------------------------------ nbrRep &lt;- 5 # [2] calculs simples # ------------------------------------------------------------ pi * nbrRep^2 ## [1] 78.53982 Pour aller plus loin sur le style de code, un guide complet de recommandations est disponible en ligne (en anglais ; http://style.tidyverse.org/). 5.4.2 Exécuter un script Depuis que nous avons un script, nous ne travaillons plus directement dans la console. Or seule la console est capable d’interpérter le code R et de nous renvoyer les résultats que nous souhaitons obtenir. Pour l’instant la technique la plus simple consiste à copier-coller les lignes que nous souhaitons éxécuter depuis notre script vers la console. A partir de maintenant nous n’allons plus utiliser les éditeurs de texte comme le bloc note mais des éditeurs spécialisés pour la confection de scripts R. C’est l’objet du chapitre suivant. 5.5 Conclusion Félicitations, nous avons atteint la fin de ce premier chapitre sur les éléments de base de R. Nous savons: Installer R Utiliser R comme une calculatrice Créez objets et les utiliser pour les calculs arithmétiques, de comparaison et de logique Choisir des noms pertinents pour les objets Créer de nouveaux script Choisir un nom pertinent pour les fichiers de script Exécuter le code d’un script Documenter les scripts avec des commentaires Utiliser un style de code pour le rendre agréable à lire et facile à comprendre "],
["IDE.html", " 6 Choisir un environnement de développement 6.1 Editeurs de texte et environnement de développement 6.2 RStudio 6.3 Notepad++ avec Npp2R 6.4 Geany (pour Linux, Mac OSX et Windows) 6.5 Autres solutions 6.6 Conclusion", " 6 Choisir un environnement de développement 6.1 Editeurs de texte et environnement de développement Il existe de très nombreux éditeurs de texte, le chapitre précédent a permit d’en introduire quelque uns parmis les plus simples comme le bloc note de Windows. Rapidement les limites de ces éditeurs ont rendu la tâche d’écrire un script fastidieuse. En effet, même en structurant son script avec des commentaires, il reste difficile de se répérer dans celui-ci. C’est là qu’interviennent les éditeurs de texte spécialisés qui vont permettre une écriture et une lecture agréable et simplifiée. L’éditeur de texte pour R certqinement le plus répandu est Rstudio, mais il en existe bien d’autres. Faire une liste exhaustive de toutes les solutions disponibles sort du cadre de ce livre, ainsi nous nous focaliserons sur les trois solutions que j’utilise au quotidien que sont Notepad++, Rstudio, et Geany. 6.2 RStudio Figure 6.1: Logo RStudio. 6.2.1 Installer RStudio Le programme pour installer Rstudio se retrouve dans la partie Products du site web de Rstudio (https://www.rstudio.com/). Nous allons installé RStudio pour un usage local (sur notre ordinateur), donc la version qui nous intéresse est Desktop. Nous allons utiliser la version Open Source qui est gratuite. Ensuite il nous suffit de sélectionner la version qui correspond à notre système d’exploitation, de télécharger le fichier correspondant et de l’exécuter pour lancer l’installation. Nous pouvons conserver les options par défaut tout au long de l’installation. 6.2.2 Un script avec RStudio Nous pouvons alors ouvrir RStudio. Lors de la première ouverture, l’interface est divisée en deux avec à gauche la console R que nous avons vu au chapitre précédent (Figure 6.2). Pour ouvrir un nouveau script, nous allons dans le menu File, New File, R script. Par défaut ce fichier a comme nom Untitled1. Nous avons vu au chapitre précédent l’importance de donner un nom pertinent à nos scripts, c’est pourquoi nous allons le renommer selecEnvDev.R, dans le menu File, avec l’option Save As…. Nous avons pu noter que la partie gauche de RStudio est désormais séparée en deux, avec en bas de l’écran la console et en haut de l’écran le script. Figure 6.2: Capture d’écran de RStudio sous Windows : fenêtre par défaut. Nous pouvons alors commencer l’écriture de notre script avec les commentaires décrivant ce que nous allons y trouver, et y ajouter un calcul simple. Une fois que nous avons recopier le code suivant, nous pouvons sauver notre script avec la commande CTRL + S ou en se rendant dans File, puis Save. # ------------------------------------------------------------ # Un script para seleccionar su entorno de desarrollo # fecha de creación : 27/06/2018 # autor : François Rebaudo # ------------------------------------------------------------ # [1] cálculos simples # ------------------------------------------------------------ nbrRep &lt;- 5 pi * nbrRep^2 ## [1] 78.53982 Pour exécuter notre script, il suffit de sélectionner les lignes que nous souhaitons exécuter et d’utiliser la combinaison de touches CTRL + ENTER. Le résultat apparaît dans la console (Figure 6.3). Figure 6.3: Capture d’écran de RStudio sous Windows : exécuter un script avec CTRL + ENTER. Nous pouvons voir que par défaut dans la partie du script les commentaires apparaissent en vert, les chiffres en bleu, et le reste du code en noir. Dans la partie de la console ce qui a été exécuté apparaît en bleu et les résultats de l’exécution en noir. Nous pouvons également noter que dans la partie du code chaque ligne comporte un numéro correspondant au numéro de ligne à gauche sur fond gris. Il s’agit de la coloration syntaxique par défaut avec RStudio. Cette coloration syntaxique peut être modifiée en se rendant dans le menu Tools, Global Options…, Appearance, puis en choisissant un autre thème dans la liste Editor theme:. Nous allons choisir le thème Cobalt, puis OK (Figure 6.4). Figure 6.4: Capture d’écran de RStudio sous Windows : changer les paramètres de coloration syntaxique. Nous savons comment créer un nouveau script, le sauvegarder, exécuter son contenu, et changer l’apparence de RStudio. Nous verrons les nombreux autres avantages de RStudio tout au long de ce livre car c’est l’environnement de développement qui sera utilisé. Nous serons néanmois particulièrement vigilents à ce que tous les scripts développés tout au long de ce livre s’exécute de la même façon quel que soit l’environnement de développement utilisé. 6.3 Notepad++ avec Npp2R Figure 6.5: Logo Notepad++ 6.3.1 Installer Notepad++ (pour Windows uniquement) Le programme pour installer Notepad++ se trouve dans l’onglet Downloads (https://notepad-plus-plus.org/download/). Vous pouvez choisir entre la version 32-bit et 64-bit (64-bit si vous ne savez pas quelle version choisir). Notepad++ seul est suffisant pour écrire un script, mais il est encore plus puissant avec Notepad to R (Npp2R) qui permet d’exécuter automatiquement nos script dans une console en local sur notre ordinateur ou à distance sur un serveur. 6.3.2 Installer Npp2R Le programme pour installer Npp2R est hébergé sur le site de Sourceforge (https://sourceforge.net/projects/npptor/). Npp2R doit être installé après Notepad++. 6.3.3 Un script avec Notepad++ Lors de la première ouverture Notepad++ affiche un fichier vide new 1 (Figura 6.6). Figure 6.6: Capture d’écran de Notepad++ sous Windows : fenêtre par défaut. Puisque nous avons déjà créer un script pour le tester avec RStudio, nous allons l’ouvrir à nouveau avec Notepad++. Dans Fichier, selectionnons Ouvrir… puis choisir le script selecEnvDev.R créé précédemment. Une fois le script ouvert, allons dans Langage, puis R, et encore une fois R. La coloration syntaxique apparaît (Figura 6.7). Figure 6.7: Capture d’écran de Notepad++ sous Windows : exécuter un script avec F8. L’execution du script ne peut se faire que si Npp2R est en cours d’exécution. Pour se faire il est nécessaire de lancer le programme Npp2R depuis l’invite de Windows. Un icône devrait apparaître en bas de votre écran. L’exécution automatique du code depuis Notepad++ se fait en sélectionnant le code à exécuter puis en utilisant la commande F8. Si la commande ne fonctionne pas et que vous venez d’installer Notepad++, il est peut être nécessaire de redémarrer votre ordinateur. Si la commande fonctionne, une nouvelle fenêtre va s’ouvrir avec une consol exécutant les lignes souhaitées (Figura 6.8. Figure 6.8: Capture d’écran de Notepad++ sous Windows : la console avec F8. Comme pour RStudio, la coloration syntaxique peut être modifiée depuis le menu Paramètres, et un nouveau thème peut être sélectionné (par exemple Solarized dans la Figura 6.9) Figure 6.9: Capture d’écran de Notepad++ sous Windows : coloration syntaxique avec le thème Solarized. Par rapport aux autres éditeurs de texte, Notepad++ a l’avantage d’être très léger et offre une vaste gamme d’options pour personnaliser l’écriture du code. 6.4 Geany (pour Linux, Mac OSX et Windows) Figure 6.10: Logo Geany 6.4.1 Installer Geany Le programme pour l’installation de Geany se trouve sous l’onglet Downloads dans le menu de gauche Releases de la page web (https://www.geany.org/). Ensuite il suffit de télécharger l’exécutable pour Windows ou le dmg pour Mac OSX. Les utilisateurs de Linux préfèrerons un sudo apt-get install geany. 6.4.2 Un script avec Geany Lors de la première ouverture, comme pour RStudio et Notepad++, un fichier vide est créé (Figure 6.11). Figure 6.11: Capture d’écran de Geany sous Windows : fenêtre par défaut. Nous pouvons ouvrir notre script avec Fichier, Ouvrir (Figure 6.12). Figure 6.12: Capture d’écran de Geany sous Windows : ouvrir un script. Pour exécuter notre script, la version de Geany pour Windows ne dispose pas d’un terminal intégré, ce qui rend son utilisation limitée sous ce système d’exploitation. L’exécution d’un script peut se faire en ouvrant R dans une fenêtre à part et en copiant et collant les lignes à exécuter. Sous Linux et Mac OSX, il suffit d’ouvrir R dans le terminal situé dans la partie basse de la fenêtre de Geany avec la commande R. Nous pouvons ensuite paramétré Geany pour qu’une combinaison de touches permette d’exécuter le code selectionné (par exemple CTRL + R). Pour cela il faut tout d’abord autoriser l’envoi de sélection vers le terminal (send_selection_unsafe=true) dans le fichier geany.conf puis choisir la commande d’envoi vers le terminal (dans Editar, Preferencias, Combinaciones). Pour changer le thème de Geany, il existe une collection de thèmes accessibles sur GitHub (https://github.com/geany/geany-themes/). Le thème peut ensuite être changé via le menu Ver, Cambiar esquema de color… (un exemple avec le thème Solarized, Figure 6.13). Figure 6.13: Capture d’écran de Geany sous Windows : changer les paramètres de coloration syntaxique. 6.5 Autres solutions Il existe beaucoup d’autres solutions, certaines spécialisées pour R comme Tinn-R (https://sourceforge.net/projects/tinn-r/), et d’autres plus généralistes pour la programmation comme Atom (https://atom.io/), Sublime Text (https://www.sublimetext.com/), Vim (https://www.vim.org/), Gedit (https://wiki.gnome.org/Apps/Gedit), GNU Emacs (https://www.gnu.org/software/emacs/), Jupyter (http://jupyter.org) ou encore Brackets (http://brackets.io/) et Eclipse (http://www.eclipse.org/). 6.6 Conclusion Felicitations, nous sommes arrivés au bout de ce chapitre sur environnements de développement pour utiliser R. Nous savons désormais : Installer RStudio, Geany ou Notepad++ Reconnaître et choisir notre environnement préféré A partir d’ici nous allons pouvoir nous concentrer sur le language de programmation R dans un environnement facilitant le travail de lecture et d’écriture du code. C’est un grand pas en avant pour maîtriser R. "],
["dataType1.html", " 7 Les types de données 7.1 Le type numeric 7.2 Le type character 7.3 Le type factor 7.4 Le type logical 7.5 A propos de NA 7.6 Conclusion", " 7 Les types de données Nous avons vu précédement comment créer un objet. Un objet est comme une boîte dans laquelle nous allons stocker de l’information. Jusqu’à présent nous n’avons stocké que des nombres mais dans ce chapitre nous allons voir qu’il est possible de stocker d’autres informations et nous allons nous attarder sur les types les plus courants. Dans ce chapitre nous allons utiliser des fonctions sur lesquelles nous reviendrons plus tard. 7.1 Le type numeric Le type numeric correspond à ce que nous avons fait jusqu’à présent, stocker des nombres. Il existe deux principaux types de nombres avec R: les nombres entiers (integers), et les nombres à virgule (double). Par défaut R considère tous les nombres comme des nombres à virgule et attribue le type double. Pour vérifier le type de données nous allons utiliser la fonction typeof() qui prend comme argument un objet (ou directement l’information que nous souhaitons tester). Nous pouvons également utiliser la fonction is.double() qui va renvoyer TRUE si le nombre est au format double et FALSE dans le cas contraire. La fonction générique is.numeric() va quant à elle renvoyer TRUE si l’objet est au format numeric et FALSE dans le cas contraire. nbrRep &lt;- 5 typeof(nbrRep) ## [1] &quot;double&quot; typeof(5.32) ## [1] &quot;double&quot; is.numeric(5) ## [1] TRUE is.double(5) ## [1] TRUE Si nous voulons spécifier à R que nous allons travailler avec un nombre entier, alors il nous faut transformer notre nombre à virgule en nombre entier avec la fonction as.integer(). Nous pouvons également utiliser la fonction is.integer() qui va renvoyer TRUE si le nombre est au format integer et FALSE dans le cas contraire. nbrRep &lt;- as.integer(5) typeof(nbrRep) ## [1] &quot;integer&quot; typeof(5.32) ## [1] &quot;double&quot; typeof(as.integer(5.32)) ## [1] &quot;integer&quot; as.integer(5.32) ## [1] 5 as.integer(5.99) ## [1] 5 is.numeric(nbrRep) ## [1] TRUE Nous voyons ici que transformer un nombre comme 5.99 au format integer va renvoyer uniquement la partie entière, soit 5. is.integer(5) ## [1] FALSE is.numeric(5) ## [1] TRUE is.integer(as.integer(5)) ## [1] TRUE is.numeric(as.integer(5)) ## [1] TRUE La somme d’un nombre entier et d’un nombre à virgule renvoie un nombre à virgule. sumIntDou &lt;- as.integer(5) + 5.2 typeof(sumIntDou) ## [1] &quot;double&quot; sumIntInt &lt;- as.integer(5) + as.integer(5) typeof(sumIntInt) ## [1] &quot;integer&quot; Pour résumer, le type numeric contient deux sous-types, les types integer pour les nombres entiers et le type double pour les nombres à virgule. Par défaut R attribue le type double aux nombres. Deux nombres particuliers doivent être considérés. Inf est un nombre de type double. Il désigne un nombre infini. Par exemple, 1/0 retourne Inf et aucun nombre ne peut être plus grand que Inf. NaN est une valeur qui signifie Not a Number : par exemple 0/0 retourne NaN. Cela peut être testé par is.nan(0/0). Attention à ne pas confondre avec NA qui désigne une donnée absente (voir plus loin). Attention, il y a un piège à l’utilisation de la fonction is.integer(). Elle ne nous dit pas si le nombre est un entier mais si il est du type integer. En effet, on peut très bien stocker un nombre entier dans une variable de type double. Les nombres stockés dans une variable integer sont codés sur 32 bits et donc peuvent prendre des valeurs comprises entre 0 et 2^32-1=4294967295. Il existe une autre façon d’indiquer à R qu’un nombre est un entier, en utilisant le suffixe L. Par exemple, 5L est la même chose que as.integer(5). L’origine de ce suffixe L date d’une époque où les ordinateurs utilisaient des mots de 16 bits et 32 bits étaient bien un type Long. Maintenant les ordinateurs utilisent des mots de 64 bits et 32 bits est plutôt court ! On ne peut pas quitter cette section sans mentionner les fonctions ceiling(), floor(), trunc() ou round() qui retournent la partie entière d’un nombre mais le laisse au type double. Pour en savoir plus, nous pouvons utiliser l’aide de R avec ?round. roundDou &lt;- round(5.2) typeof(roundDou) ## [1] &quot;double&quot; 7.2 Le type character Le type character correspond au texte. En effet, R permet de travailler avec du texte. pour spécifier à R que l’information contenue dans un objet est au format texte (ou de manière générale pour tous les textes), il faut utiliser les guillemets doubles (&quot;), ou simples ('). myText &lt;- &quot;azerty&quot; myText2 &lt;- &#39;azerty&#39; myText3 &lt;- &#39;azerty uiop qsdfg hjklm&#39; typeof(myText3) ## [1] &quot;character&quot; Les guillemets doubles ou simples sont utiles si l’on souhaite mettre des guillemets dans notre texte. Nous pouvons également échapper un caractère spécial comme un guillemet grâce au signe backslash \\. myText &lt;- &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; myText2 &lt;- &#39;a &quot;zert&quot; y&#39; myText3 &lt;- &#39;azerty uiop qsdfg hjklm&#39; myText4 &lt;- &quot;qwerty \\&quot; azerty &quot; myText5 &lt;- &quot;qwerty \\\\ azerty &quot; Par défaut lorsque nous créons un objet, son contenu n’est pas renvoyé par la console. Sur Internet ou dans de nombreux ouvrages nous pouvons retrouver le nom de l’objet sur une ligne pour renvoyer son contenu: myText &lt;- &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; myText ## [1] &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; Dans ce livre nous n’utiliserons jamais cette façon de faire et préfèrerons l’utilisation de la fonction print(), qui permet d’afficher dans la console le contenu d’un objet. Le résultat est le même mais le code est alors plus facile à lire et plus explicite sur ce qui est fait. myText &lt;- &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; print(myText) ## [1] &quot;a &#39;ze&#39; &#39;rt&#39; y&quot; nbrRep &lt;- 5 print(nbrRep) ## [1] 5 Nous pouvons également mettre des chiffres au format texte, mais il ne faut pas oublier de mettre des guillemets pour spécifier le type character ou utiliser la fonction as.character(). Une opération entre du texte et un nombre renvoie une erreur. Par exemple si l’on ajoute 10 à &quot;5&quot;, R nous signale qu’un argument de la fonction + n’est pas de type numeric et que donc l’opération n’est pas possible. Nous ne pouvons pas non plus ajouter du texte à du texte, mais verrons plus tard comment concaténer deux chaines de texte. myText &lt;- &quot;qwerty&quot; typeof(myText) ## [1] &quot;character&quot; myText2 &lt;- 5 typeof(myText2) ## [1] &quot;double&quot; myText3 &lt;- &quot;5&quot; typeof(myText3) ## [1] &quot;character&quot; myText2 + 10 ## [1] 15 as.character(5) ## [1] &quot;5&quot; # myText3 + 10 # Error in myText3 + 10 : non-numeric argument to binary operator # &quot;a&quot; + &quot;b&quot; # Error in &quot;a&quot; + &quot;b&quot; : non-numeric argument to binary operator Pour résumer, le type character permet la saisie de texte, nous pouvons le reconnaître grâce aux guillemets simples ou doubles. 7.3 Le type factor Le type factor correspond aux facteurs. Les facteurs sont un choix parmi une liste finie de possibilités. Par exemple les pays sont des facteurs car il y a une liste finie de pays dans le monde à un temps donné. Un facteur peut être défini avec la fonction factor() ou transformé en utilisant la fonction as.factor(). Comme pour les autres types de donnée nous pouvons utiliser la fonction is.factor() pour vérifier le type de donnée. Pour avoir la liste de toutes les possibilités, il existe la fonction levels() (cette fonction prendra plus de sens quand nous aurons abordé les types de conteneur de l’information). factor01 &lt;- factor(&quot;aaa&quot;) print(factor01) ## [1] aaa ## Levels: aaa typeof(factor01) ## [1] &quot;integer&quot; is.factor(factor01) ## [1] TRUE levels(factor01) ## [1] &quot;aaa&quot; Un facteur peut être transformé en texte avec la fonction as.character() mais également en nombre avec as.numeric(). Lors de la transformation en nombre chaque facteur prend la valeur de sa position dans la liste des possibilités. Dans notre cas il n’y a qu’une seule possibilité donc la fonction as.numeric() va renvoyer 1: factor01 &lt;- factor(&quot;aaa&quot;) as.character(factor01) ## [1] &quot;aaa&quot; as.numeric(factor01) ## [1] 1 7.4 Le type logical Le type logical correspond aux valeurs TRUE et FALSE (et NA) que nous avons déjà vu avec les opérateurs de comparaison. aLogic &lt;- TRUE print(aLogic) ## [1] TRUE typeof(aLogic) ## [1] &quot;logical&quot; is.logical(aLogic) ## [1] TRUE aLogic + 1 ## [1] 2 as.numeric(aLogic) ## [1] 1 as.character(aLogic) ## [1] &quot;TRUE&quot; 7.5 A propos de NA La valeur NA peut être utilisée pour spécifier l’absence de données ou les données manquantes. Par défaut NA est de type logical mais il peut être utilisé pour du texte, ou des nombres. print(NA) ## [1] NA typeof(NA) ## [1] &quot;logical&quot; typeof(as.integer(NA)) ## [1] &quot;integer&quot; typeof(as.character(NA)) ## [1] &quot;character&quot; NA == TRUE ## [1] NA NA == FALSE ## [1] NA NA &gt; 1 ## [1] NA NA + 1 ## [1] NA 7.6 Conclusion Felicitations, nous sommes arrivés au bout de ce chapitre sur les type de données. Nous savons désormais : Reconnaîte et faire des objets dans les principaux types de données Transformer les types de données d’un type à un autre Ce chapitre un peu fastidieux est la base pour aborder le prochain chapitre sur les conteneurs des données. "],
["dataType2.html", " 8 Les conteneurs de données 8.1 Le conteneur vector 8.2 Le conteneur list 8.3 Le conteneur data.frame 8.4 Le conteneur matrix 8.5 Le conteneur array 8.6 Conclusion", " 8 Les conteneurs de données Jusqu’à présent nous avons fait des objets simples ne contenant qu’une seule valeur. Nous avons néanmoins pu voir qu’un objet avait différents attributs, comme sa valeur, mais aussi le type de donnée contenue. maintenant nous allons voir qu’il existe différents types de conteneurs permettant de stocker plusieurs données. 8.1 Le conteneur vector Dans R, un vector est une combinaison de données avec la particularité que toutes les données contenues dans un vector sont du même type. Nous pouvons donc stocker plusieurs numeric ou character dans un vector, mais pas les deux. Le conteneur vector est important car c’est l’élément de base de R. 8.1.1 Créer un vector Pour créer un vector nous allons utiliser la fonction c() qui permet de combiner des éléments en un vector. Les éléments à combiner doivent être séparés par des virgules. miVec01 &lt;- c(1, 2, 3, 4) # un vecteur de 4 éléments de type numeric ; double print(miVec01) ## [1] 1 2 3 4 typeof(miVec01) ## [1] &quot;double&quot; is.vector(miVec01) ## [1] TRUE La fonction is.vector() permet de vérifier le type de conteneur. miVec02 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) print(miVec02) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; typeof(miVec02) ## [1] &quot;character&quot; is.vector(miVec02) ## [1] TRUE miVec03 &lt;- c(TRUE, FALSE, FALSE, TRUE) print(miVec03) ## [1] TRUE FALSE FALSE TRUE typeof(miVec03) ## [1] &quot;logical&quot; is.vector(miVec03) ## [1] TRUE miVecNA &lt;- c(1, NA, 3, NA, 5) print(miVecNA) ## [1] 1 NA 3 NA 5 typeof(miVecNA) ## [1] &quot;double&quot; is.vector(miVecNA) ## [1] TRUE miVec04 &lt;- c(1, &quot;a&quot;) print(miVec04) ## [1] &quot;1&quot; &quot;a&quot; typeof(miVec04) ## [1] &quot;character&quot; is.vector(miVec04) ## [1] TRUE Si l’on combine différents types de données, par défaut R va chercher à transformer les éléments en un seul type. Si comme ici dans l’objet miVec03 nous avons des character et des numeric, R va transformer tous les éléments en character. miVec05 &lt;- c(factor(&quot;abc&quot;), &quot;def&quot;) print(miVec05) ## [1] &quot;1&quot; &quot;def&quot; typeof(miVec05) ## [1] &quot;character&quot; miVec06 &lt;- c(TRUE, &quot;def&quot;) print(miVec06) ## [1] &quot;TRUE&quot; &quot;def&quot; typeof(miVec06) ## [1] &quot;character&quot; miVec07 &lt;- c(factor(&quot;abc&quot;), 55) print(miVec07) ## [1] 1 55 typeof(miVec07) ## [1] &quot;double&quot; miVec08 &lt;- c(TRUE, 55) print(miVec08) ## [1] 1 55 typeof(miVec08) ## [1] &quot;double&quot; Nous pouvons aussi combiner des objets existants au sein d’un vector. miVec09 &lt;- c(miVec02, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;) print(miVec09) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; miVec10 &lt;- c(&quot;aaa&quot;, &quot;aa&quot;, miVec09, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;) print(miVec10) ## [1] &quot;aaa&quot; &quot;aa&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; miVec11 &lt;- c(789, miVec01 , 564) print(miVec11) ## [1] 789 1 2 3 4 564 8.1.2 Opérations sur un vector Nous pouvons également effectuer des opération sur un vector. print(miVec01) ## [1] 1 2 3 4 miVec01 + 1 ## [1] 2 3 4 5 miVec01 - 1 ## [1] 0 1 2 3 miVec01 * 2 ## [1] 2 4 6 8 miVec01 /10 ## [1] 0.1 0.2 0.3 0.4 Les opérations d’un vector sur un autre sont aussi possibles, mais il faut veiller à ce que le nombre d’éléments d’un vector soit le même que l’autre, sinon R va effectuer le calcul en repartant du début. Voici un exemple pour illustrer ce que R fait: miVec12 &lt;- c(1, 1, 1, 1, 1, 1, 1, 1, 1) print(miVec12) ## [1] 1 1 1 1 1 1 1 1 1 miVec13 &lt;- c(10, 20, 30) print(miVec13) ## [1] 10 20 30 miVec12 + miVec13 # vecteurs de tailles différentes : attention au résultat ## [1] 11 21 31 11 21 31 11 21 31 miVec14 &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90) print(miVec14) ## [1] 10 20 30 40 50 60 70 80 90 miVec12 + miVec14 # les vecteurs sont de la même longueur ## [1] 11 21 31 41 51 61 71 81 91 miVec15 &lt;- c(1, 1, 1, 1) print(miVec15) ## [1] 1 1 1 1 miVec15 + miVec13 # vecteurs de tailles différentes et non multiples ## Warning in miVec15 + miVec13: la taille d&#39;un objet plus long n&#39;est pas ## multiple de la taille d&#39;un objet plus court ## [1] 11 21 31 11 8.1.3 Accèder aux valeurs d’un vector Il souvent nécessaire de pouvoir accèder aux valeurs d’un vector, c’est à dire de récupérer une valeur ou un groupe de valeurs au sein d’un vector. Pour à un élément dans un vector nous utilisons les crochets []. Entre les crochets, nous pouvons utiliser un numéro correspondant au numéro de l’élément dans le vector. miVec20 &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90) miVec21 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;) print(miVec20) ## [1] 10 20 30 40 50 60 70 80 90 print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec20[1]) ## [1] 10 print(miVec21[3]) ## [1] &quot;c&quot; Nous pouvons aussi utiliser la combinaison de différents éléments (un autre vector). print(miVec20[c(1, 5, 9)]) ## [1] 10 50 90 print(miVec21[c(4, 3, 1)]) ## [1] &quot;d&quot; &quot;c&quot; &quot;a&quot; print(miVec21[c(4, 4, 3, 4, 3, 2, 5)]) ## [1] &quot;d&quot; &quot;d&quot; &quot;c&quot; &quot;d&quot; &quot;c&quot; &quot;b&quot; &quot;e&quot; Nous pouvons aussi selectionner des éléments en utilisant un opérateur de comparaison ou un opérateur logique. print(miVec20[miVec20 &gt;= 50]) ## [1] 50 60 70 80 90 print(miVec20[(miVec20 &gt;= 50) &amp; ((miVec20 &lt; 80))]) ## [1] 50 60 70 print(miVec20[miVec20 != 50]) ## [1] 10 20 30 40 60 70 80 90 print(miVec20[miVec20 == 30]) ## [1] 30 print(miVec20[(miVec20 == 30) | (miVec20 == 50)]) ## [1] 30 50 print(miVec21[miVec21 == &quot;a&quot;]) ## [1] &quot;a&quot; Une autre fonctionnalité intéressante est de conditionner les éléments à sélectionner dans un vector en fonction d’un autre vector. print(miVec21[miVec20 &gt;= 50]) ## [1] &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec21[(miVec20 &gt;= 50) &amp; ((miVec20 &lt; 80))]) ## [1] &quot;e&quot; &quot;f&quot; &quot;g&quot; print(miVec21[miVec20 != 50]) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec21[miVec20 == 30]) ## [1] &quot;c&quot; print(miVec21[(miVec20 == 30) | (miVec20 == 50)]) ## [1] &quot;c&quot; &quot;e&quot; print(miVec21[(miVec20 == 30) | (miVec21 == &quot;h&quot;)]) ## [1] &quot;c&quot; &quot;h&quot; Il est aussi possible d’exclure certains éléments plutôt que de les sélectionner. print(miVec20[-1]) ## [1] 20 30 40 50 60 70 80 90 print(miVec21[-5]) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(miVec20[-c(1, 2, 5)]) ## [1] 30 40 60 70 80 90 print(miVec21[-c(1, 2, 5)]) ## [1] &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; Les éléments d’un vector peuvent aussi être sélectionné sur la base d’un vector de type logical. Dans ce cas seuls les éléments avec une valeur TRUE seront sélectionnés. miVec22 &lt;- c(TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE) print(miVec21[miVec22]) ## [1] &quot;a&quot; &quot;b&quot; &quot;d&quot; &quot;f&quot; &quot;h&quot; &quot;i&quot; 8.1.4 Nommer les éléments d’un vector Les éléments d’un vector peuvent être nommé pour pouvoir s’y référer par la suite et opérer une sélection. La fonction names() permet de récupérer les noms des éléments d’un vecteur. miVec23 &lt;- c(aaa = 10, bbb = 20, ccc = 30, ddd = 40, eee = 50) print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 30 40 50 print(miVec23[&quot;bbb&quot;]) ## bbb ## 20 print(miVec23[c(&quot;bbb&quot;, &quot;ccc&quot;, &quot;bbb&quot;)]) ## bbb ccc bbb ## 20 30 20 names(miVec23) ## [1] &quot;aaa&quot; &quot;bbb&quot; &quot;ccc&quot; &quot;ddd&quot; &quot;eee&quot; 8.1.5 Modifier les éléments d’un vector Pour modifier un vecteur, nous opérons de la même façon que pour modifier un objet simple, avec le signe &lt;- et l’élément ou les éléments à modifier entre crochets. print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miVec21[3] &lt;- &quot;zzz&quot; print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;zzz&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miVec21[(miVec20 &gt;= 50) &amp; ((miVec20 &lt; 80))] &lt;- &quot;qwerty&quot; print(miVec21) ## [1] &quot;a&quot; &quot;b&quot; &quot;zzz&quot; &quot;d&quot; &quot;qwerty&quot; &quot;qwerty&quot; &quot;qwerty&quot; &quot;h&quot; ## [9] &quot;i&quot; print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 30 40 50 miVec23[&quot;ccc&quot;] &lt;- miVec23[&quot;ccc&quot;] + 100 print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 130 40 50 Nous pouvons aussi changer les noms associés aux éléments d’un vector. print(miVec23) ## aaa bbb ccc ddd eee ## 10 20 130 40 50 names(miVec23)[2] &lt;- &quot;bb_bb&quot; print(miVec23) ## aaa bb_bb ccc ddd eee ## 10 20 130 40 50 Nous pouvons faire bien plus avec un vector et reviendrons sur leur manipulations et les opérations lors du chapitre sur les fonctions. 8.2 Le conteneur list Le deuxième type de conteneur que nous allons introduire est le conteneur list, qui est également le deuxième conteneur après le type vector de part son importance dans la programmation avec R. Le conteneur de type list permet de stocker une liste d’éléments. Contrairement à ce que nous avons vu précédement avec le type vector, les éléments du type list peuvent être différents (par exemple un vector de type numeric, puis un vecteur de type character). Les éléments du type list peuvent aussi être des conteneurs différents (par exemple un vector, puis une list). Le type de conteneur list prendra tout son sens lorsque nous aurons étudié les boucles et les fonctions de la famille apply. 8.2.1 Créer une list Pour créer une list nous allons utiliser la fonction list() qui prend comme argument des éléments (objets). miList01 &lt;- list() print(miList01) ## list() miList02 &lt;- list(5, &quot;qwerty&quot;, c(4, 5, 6), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) print(miList02) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; miList03 &lt;- list(5, &quot;qwerty&quot;, list(c(4, 5, 6), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))) print(miList03) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [[3]][[1]] ## [1] 4 5 6 ## ## [[3]][[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; La fonction is.list() permet de tester si nous avons bien créer un objet de type list. is.list(miList02) ## [1] TRUE typeof(miList02) ## [1] &quot;list&quot; 8.2.2 Accéder aux valeurs d’une list Les éléments du conteneur list sont identifiables grâce aux double crochets [[ ]]. print(miList02) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Dans l’objet miList02 de type list, il y a quatre éléments identifiables avec [[1]], [[2]], [[3]], et [[4]]. Chacun des éléments est de type vector de taille 1 et de type double pour le premier élément, de taille 1 et de type character pour le deuxième élément, de taille 3 et de type double pour le troisième élément, et de taille 3 et de type character pour le quatrième élément. typeof(miList02) ## [1] &quot;list&quot; print(miList02[[1]]) ## [1] 5 typeof(miList02[[1]]) ## [1] &quot;double&quot; print(miList02[[2]]) ## [1] &quot;qwerty&quot; typeof(miList02[[2]]) ## [1] &quot;character&quot; print(miList02[[3]]) ## [1] 4 5 6 typeof(miList02[[3]]) ## [1] &quot;double&quot; print(miList02[[4]]) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; typeof(miList02[[4]]) ## [1] &quot;character&quot; L’accès au deuxième élément du vector situé en quatrième position de la liste se fait donc avec miList02[[4]][2]. Nous utilisons un double crochet pour le quatrième élément de la list, puis un simple crochet pour le deuxième élément du vector. print(miList02[[4]][2]) ## [1] &quot;b&quot; Comme une list peut contenir elle même une ou plusieurs list, nous pouvons accéder à l’information recherchée en combinant les doubles crochets. l’objet miList04 est une list de deux éléments, les list miList02 et miList03. L’objet miList03 contient lui même une list comme élément en troisième position. Pour accéder au premier élément du vector en première position de l’élément en troisième position du deuxième élément de la list miList04, nous pouvons utiliser miList04[[2]][[3]][[1]][1]. Il n’y a pas de limite quant à la profondeur des list mais dans la pratique il n’y que rarement besoin de faire des list de list de list. miList04 &lt;- list(miList02, miList03) print(miList04) ## [[1]] ## [[1]][[1]] ## [1] 5 ## ## [[1]][[2]] ## [1] &quot;qwerty&quot; ## ## [[1]][[3]] ## [1] 4 5 6 ## ## [[1]][[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## ## [[2]] ## [[2]][[1]] ## [1] 5 ## ## [[2]][[2]] ## [1] &quot;qwerty&quot; ## ## [[2]][[3]] ## [[2]][[3]][[1]] ## [1] 4 5 6 ## ## [[2]][[3]][[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; print(miList04[[2]][[3]][[1]][1]) ## [1] 4 Pour rendre concret l’exemple précédent, nous pouvons imaginer des espèces de foreurs de maïs (Sesamia nonagrioides et Ostrinia nubilalis), échantillonées dans différents sites, avec différentes abondances à quatre dates. Ici nous allons donner des noms aux éléments des listes. bddInsect &lt;- list(Snonagrioides = list(site01 = c(12, 5, 8, 7), site02 = c(5, 23, 4, 41), site03 = c(12, 0, 0, 0)), Onubilalis = list(site01 = c(12, 1, 2, 3), site02 = c(0, 0, 0, 1), site03 = c(1, 1, 2, 3))) print(bddInsect) ## $Snonagrioides ## $Snonagrioides$site01 ## [1] 12 5 8 7 ## ## $Snonagrioides$site02 ## [1] 5 23 4 41 ## ## $Snonagrioides$site03 ## [1] 12 0 0 0 ## ## ## $Onubilalis ## $Onubilalis$site01 ## [1] 12 1 2 3 ## ## $Onubilalis$site02 ## [1] 0 0 0 1 ## ## $Onubilalis$site03 ## [1] 1 1 2 3 La lecture d’une ligne de code longue comme celle de la création de l’objet bddInsect est difficile à lire car la profondeur des éléments ne peut se déduire que grâce aux parenthèses. C’est pourquoi nous allons reorganiser le code pour lui donner plus de lisibilité grâce à l’indentation. L’indentation consiste à mettre l’information à des niveaux différents de telle manière que nous puissions rapidement identifier les différents niveaux d’un code. L’indentation se fait au moyen de la touche de tabulation du clavier. Nous reviendrons sur l’indentation avec plus de précisions lors du chapitre sur les boucles. Nous retiendrons pour le moment que si une ligne de code est trop longue, nous gagnons en lisibilité en passant à la ligne et que R va lire l’ensemble comme une seule ligne de code. bddInsect &lt;- list( Snonagrioides = list( site01 = c(12, 5, 8, 7), site02 = c(5, 23, 4, 41), site03 = c(12, 0, 0, 0) ), Onubilalis = list( site01 = c(12, 1, 2, 3), site02 = c(0, 0, 0, 1), site03 = c(1, 1, 2, 3) ) ) Nous pouvons sélectionner les données d’abondance du deuxième site de la première espèce comme précédemment bddInsect[[1]][[2]], ou alternativement en utilisant les noms des éléments bddInsect$Snonagrioides$site02. Pour ce faire nous utilisons le signe $, ou alors le nom des éléments avec des guillemets simples ou doubles bddInsect[['Snonagrioides']][['site02']]. print(bddInsect[[1]][[2]]) ## [1] 5 23 4 41 print(bddInsect$Snonagrioides$site02) ## [1] 5 23 4 41 print(bddInsect[[&#39;Snonagrioides&#39;]][[&#39;site02&#39;]]) ## [1] 5 23 4 41 Comme pour les vecteurs nous pouvons récupérer les noms des éléments avec la fonction names(). names(bddInsect) ## [1] &quot;Snonagrioides&quot; &quot;Onubilalis&quot; names(bddInsect[[1]]) ## [1] &quot;site01&quot; &quot;site02&quot; &quot;site03&quot; Lorsque nous utilisons les doubles crochets [[]] ou le signe $, R renvoie le contenu de l’élément sélectionné. Dans notre exemple les données d’abondance sont contenues sous la forme d’un vector, donc R renvoie un élément de type vector. Si nous souhaitons sélectionner un élément d’une list mais en conservant le format list, alors nous pouvons utiliser les crochets simples []. print(bddInsect[[1]][[2]]) ## [1] 5 23 4 41 typeof(bddInsect[[1]][[2]]) ## [1] &quot;double&quot; is.list(bddInsect[[1]][[2]]) ## [1] FALSE print(bddInsect[[1]][2]) ## $site02 ## [1] 5 23 4 41 typeof(bddInsect[[1]][2]) ## [1] &quot;list&quot; is.list(bddInsect[[1]][2]) ## [1] TRUE L’utilisation des crochets simples [] est utile lorsque nous souhaitons récupérer plusieurs éléments d’une list. Par exemple pour sélectionner les abondances d’insectes des deux premiers sites de la première espèce, nous utiliserons bddInsect[[1]][c(1, 2)] ou alternativement bddInsect[[1]][c(&quot;site01&quot;, &quot;site02&quot;)]. print(bddInsect[[1]][c(1, 2)]) ## $site01 ## [1] 12 5 8 7 ## ## $site02 ## [1] 5 23 4 41 print(bddInsect[[1]][c(&quot;site01&quot;, &quot;site02&quot;)]) ## $site01 ## [1] 12 5 8 7 ## ## $site02 ## [1] 5 23 4 41 8.2.3 Modification d’une list Une list peut être modifiée de la même façon que pour le conteneur vector, c’est à dire en se réferrant avec des crochets à l’élément que nous souhaitons modifier. print(miList02) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; miList02[[1]] &lt;- 12 print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; miList02[[4]] &lt;- c(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;) print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;d&quot; &quot;e&quot; &quot;f&quot; miList02[[4]] &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, miList02[[4]], &quot;g&quot;, &quot;h&quot;, &quot;i&quot;) print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miList02[[4]][5] &lt;- &quot;eee&quot; print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 4 5 6 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miList02[[3]] &lt;- miList02[[3]] * 10 - 1 print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 39 49 59 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; miList02[[3]][2] &lt;- miList02[[1]] * 100 print(miList02) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 39 1200 59 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; print(bddInsect) ## $Snonagrioides ## $Snonagrioides$site01 ## [1] 12 5 8 7 ## ## $Snonagrioides$site02 ## [1] 5 23 4 41 ## ## $Snonagrioides$site03 ## [1] 12 0 0 0 ## ## ## $Onubilalis ## $Onubilalis$site01 ## [1] 12 1 2 3 ## ## $Onubilalis$site02 ## [1] 0 0 0 1 ## ## $Onubilalis$site03 ## [1] 1 1 2 3 bddInsect[[&#39;Snonagrioides&#39;]][[&#39;site02&#39;]] &lt;- c(2, 4, 6, 8) print(bddInsect) ## $Snonagrioides ## $Snonagrioides$site01 ## [1] 12 5 8 7 ## ## $Snonagrioides$site02 ## [1] 2 4 6 8 ## ## $Snonagrioides$site03 ## [1] 12 0 0 0 ## ## ## $Onubilalis ## $Onubilalis$site01 ## [1] 12 1 2 3 ## ## $Onubilalis$site02 ## [1] 0 0 0 1 ## ## $Onubilalis$site03 ## [1] 1 1 2 3 Pour combiner deux list, il suffit d’utiliser la fonction c() que nous avions utilisée pour créer un vector. miList0203 &lt;- c(miList02, miList03) print(miList0203) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] &quot;qwerty&quot; ## ## [[3]] ## [1] 39 1200 59 ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;eee&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; ## ## [[5]] ## [1] 5 ## ## [[6]] ## [1] &quot;qwerty&quot; ## ## [[7]] ## [[7]][[1]] ## [1] 4 5 6 ## ## [[7]][[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Un objet de type list peut être transformé en vector avec la fonction unlist() si le format des éléments de la list le permet (un vector ne peut contenir que des élément du même type). miList05 &lt;- list(&quot;a&quot;, c(&quot;b&quot;, &quot;c&quot;), &quot;d&quot;) print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; miVec24 &lt;- unlist(miList05) print(miVec24) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; miList06 &lt;- list(c(1, 2, 3), c(4, 5, 6, 7), 8, 9, c(10, 11)) print(miList06) ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] 4 5 6 7 ## ## [[3]] ## [1] 8 ## ## [[4]] ## [1] 9 ## ## [[5]] ## [1] 10 11 miVec25 &lt;- unlist(miList06) print(miVec25) ## [1] 1 2 3 4 5 6 7 8 9 10 11 Pour ajouter un élément à une list, nous pouvons utiliser la fonction c() ou alors les crochets doubles [[]]. print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; miList05 &lt;- c(miList05, &quot;e&quot;) print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; ## ## [[4]] ## [1] &quot;e&quot; miList05[[5]] &lt;- c(&quot;fgh&quot;, &quot;ijk&quot;) print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; ## ## [[4]] ## [1] &quot;e&quot; ## ## [[5]] ## [1] &quot;fgh&quot; &quot;ijk&quot; Pour supprimer un élément à une list, la technique la plus rapide consiste à attribuer la valeur NULL à l’élément à supprimer. print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;b&quot; &quot;c&quot; ## ## [[3]] ## [1] &quot;d&quot; ## ## [[4]] ## [1] &quot;e&quot; ## ## [[5]] ## [1] &quot;fgh&quot; &quot;ijk&quot; miList05[[2]] &lt;- NULL print(miList05) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## [1] &quot;d&quot; ## ## [[3]] ## [1] &quot;e&quot; ## ## [[4]] ## [1] &quot;fgh&quot; &quot;ijk&quot; 8.3 Le conteneur data.frame Le conteneur data.frame peut être assimilé à un tableau. Il s’agit en fait d’un cas particulier de list où tous les éléments de la list ont la même longueur. 8.3.1 Créer un data.frame Pour créer un data.frame nous allons utiliser la fonction data.frame() qui prend comme arguments les éléments du tableau que nous souhaitons créer. Les éléments sont de type vector et font tous la même taille. Nous pouvons donner un nom à chaque colonne (vector) de notre tableau (data.frame). # création d&#39;un data.frame miDf01 &lt;- data.frame( numbers = c(1, 2, 3, 4), logicals = c(TRUE, TRUE, FALSE, TRUE), characters = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) ) print(miDf01) ## numbers logicals characters ## 1 1 TRUE a ## 2 2 TRUE b ## 3 3 FALSE c ## 4 4 TRUE d # création des vecteurs, puis du data.frame numbers &lt;- c(1, 2, 3, 4) logicals &lt;- c(TRUE, TRUE, FALSE, TRUE) characters &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) miDf01 &lt;- data.frame(numbers, logicals, characters) print(miDf01) ## numbers logicals characters ## 1 1 TRUE a ## 2 2 TRUE b ## 3 3 FALSE c ## 4 4 TRUE d 8.3.2 Accèder aux valeurs d’un data.frame L’accès aux différentes valeurs d’un data.frame peut se faire de la même façon que pour un conteneur de type list. print(miDf01$numbers) # vector ## [1] 1 2 3 4 print(miDf01[[1]]) # vector ## [1] 1 2 3 4 print(miDf01[1]) # list ## numbers ## 1 1 ## 2 2 ## 3 3 ## 4 4 print(miDf01[&quot;numbers&quot;]) # list ## numbers ## 1 1 ## 2 2 ## 3 3 ## 4 4 print(miDf01[[&quot;numbers&quot;]]) # vector ## [1] 1 2 3 4 Nous pouvons aussi utiliser une aute forme qui consiste à spécifier le ou les lignes suivi d’une virgule (et donc d’un espace après la virgule), puis le ou les colonnes entre crochets simples. Si l’information ligne ou colonne est omise, R affichera toutes les lignes ou toutes les colonnes. Là encore nous pouvons utiliser le numéro correspondant à un élément ou alors le nom de l’élément que nous souhaitons sélectionner. myRow &lt;- 2 myCol &lt;- 1 print(miDf01[myRow, myCol]) ## [1] 2 print(miDf01[myRow, ]) ## numbers logicals characters ## 2 2 TRUE b print(miDf01[, myCol]) ## [1] 1 2 3 4 myCol &lt;- &quot;numbers&quot; print(miDf01[, myCol]) ## [1] 1 2 3 4 Il est possible de sélectionner plusieurs lignes ou plusieurs colonnes. print(miDf01[, c(1, 2)]) ## numbers logicals ## 1 1 TRUE ## 2 2 TRUE ## 3 3 FALSE ## 4 4 TRUE print(miDf01[c(2, 1), ]) ## numbers logicals characters ## 2 2 TRUE b ## 1 1 TRUE a Puisque chaque colonne est au format vector, nous pouvons également faire une sélection qui dépendra du contenu avec les opérateurs de comparaison et les opérateurs logiques. miDfSub01 &lt;- miDf01[miDf01$numbers &gt; 2, ] print(miDfSub01) ## numbers logicals characters ## 3 3 FALSE c ## 4 4 TRUE d miDfSub02 &lt;- miDf01[(miDf01$logicals == TRUE) &amp; (miDf01$numbers &lt; 2), ] print(miDfSub02) ## numbers logicals characters ## 1 1 TRUE a miDfSub03 &lt;- miDf01[(miDf01$numbers %% 2) == 0, ] print(miDfSub03) ## numbers logicals characters ## 2 2 TRUE b ## 4 4 TRUE d miDfSub04 &lt;- miDf01[((miDf01$numbers %% 2) == 0) | (miDf01$logicals == TRUE), ] print(miDfSub04) ## numbers logicals characters ## 1 1 TRUE a ## 2 2 TRUE b ## 4 4 TRUE d 8.3.3 Modifier un data.frame Pour ajouter un élément à un data.frame, nous allons procéder comme pour un conteneur de type list. Il faudra veiller à ce que le nouvel éléménet soit de la même taille que les autres éléments de notre data.frame. Par défaut un nouvel élément dans un data.frame prend comme nom la lettre V suivie du numéro de la colonne. Nous pouvons changer les noms de colonne avec la fonction colnames(). Nous avons la possibilité de donner un nom aux lignes avec la fonction rownames() newVec &lt;- c(4, 5, 6, 7) miDf01[[4]] &lt;- newVec print(miDf01) ## numbers logicals characters V4 ## 1 1 TRUE a 4 ## 2 2 TRUE b 5 ## 3 3 FALSE c 6 ## 4 4 TRUE d 7 print(colnames(miDf01)) ## [1] &quot;numbers&quot; &quot;logicals&quot; &quot;characters&quot; &quot;V4&quot; colnames(miDf01)[4] &lt;- &quot;newVec&quot; print(miDf01) ## numbers logicals characters newVec ## 1 1 TRUE a 4 ## 2 2 TRUE b 5 ## 3 3 FALSE c 6 ## 4 4 TRUE d 7 print(rownames(miDf01)) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; rownames(miDf01) &lt;- c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;, &quot;row4&quot;) print(miDf01) ## numbers logicals characters newVec ## row1 1 TRUE a 4 ## row2 2 TRUE b 5 ## row3 3 FALSE c 6 ## row4 4 TRUE d 7 newVec2 &lt;- c(40, 50, 60, 70) miDf01$newVec2 &lt;- newVec2 print(miDf01) ## numbers logicals characters newVec newVec2 ## row1 1 TRUE a 4 40 ## row2 2 TRUE b 5 50 ## row3 3 FALSE c 6 60 ## row4 4 TRUE d 7 70 Comme le type de conteneur data.frame est un cas particulier de list, la sélection et la modification se fait comme pour un conteneur de type list. Comme les éléments d’un data.frame sont de type vector, la sélection et la modification des éléments d’un data.frame se fait comme pour un conteneur de type vector. miDf01$newVec2 &lt;- miDf01$newVec2 * 2 print(miDf01) ## numbers logicals characters newVec newVec2 ## row1 1 TRUE a 4 80 ## row2 2 TRUE b 5 100 ## row3 3 FALSE c 6 120 ## row4 4 TRUE d 7 140 miDf01$newVec2 + miDf01$newVec ## [1] 84 105 126 147 miDf01$newVec2[2] &lt;- 0 print(miDf01) ## numbers logicals characters newVec newVec2 ## row1 1 TRUE a 4 80 ## row2 2 TRUE b 5 0 ## row3 3 FALSE c 6 120 ## row4 4 TRUE d 7 140 Un vector peut être transformé en data.frame avec la fonction as.data.frame(). print(newVec2) ## [1] 40 50 60 70 print(as.data.frame(newVec2)) ## newVec2 ## 1 40 ## 2 50 ## 3 60 ## 4 70 is.data.frame(newVec2) ## [1] FALSE is.data.frame(as.data.frame(newVec2)) ## [1] TRUE 8.4 Le conteneur matrix Le conteneur matrix peut être vu comme un vector à deux dimensions, les lignes et les colonnes. Il correspond à une matrice en mathématique, et ne peut contenir qu’un seul type de données (logical, numeric, character, …). 8.4.1 Créer une matrix Pour créer une matrix nous allons tout d’abord créer un vector, puis spécifier le nombre souhaité de lignes et de colonnes dans la fonction matrix(). vecForMatrix &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12) miMat &lt;- matrix(vecForMatrix, nrow = 3, ncol = 4) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 Il n’est pas nécessaire de spécifier le nombre de lignes nrow et le nombre de colonnes ncol. Si nous utilisons l’un ou l’autre de ces arguments, R va automatiquement calculer le nombre correspondant. miMat &lt;- matrix(vecForMatrix, nrow = 3) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 miMat &lt;- matrix(vecForMatrix, ncol = 4) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 Nous observons que les différents éléments du vector initial sont renseignés par colonne. Si nous souhaitons renseigner la matrix par lignes alors il faut donner la valeur TRUE à l’argument byrow. miMat &lt;- matrix(vecForMatrix, nrow = 3, byrow = TRUE) print(miMat) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Nous pouvons également donner un nom aux lignes et aux colonnes de notre matrix lors de sa création avec l’argument dimnames qui prend comme valeur une list de deux éléments : le nom des lignes puis le nom des colonnes. Nous pouvons aussi changer le nom des lignes et des colonnes a posteriori avec les fonctions rownames() et colnames(). miMat &lt;- matrix( vecForMatrix, nrow = 3, byrow = TRUE, dimnames = list(c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;), c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;, &quot;c4&quot;)) ) print(miMat) ## c1 c2 c3 c4 ## r1 1 2 3 4 ## r2 5 6 7 8 ## r3 9 10 11 12 colnames(miMat) &lt;- c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;, &quot;col4&quot;) rownames(miMat) &lt;- c(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;) print(miMat) ## col1 col2 col3 col4 ## row1 1 2 3 4 ## row2 5 6 7 8 ## row3 9 10 11 12 Il est possible de créer une matrix à partir d’un data.frame avec la fonction as.matrix() sous réserve que le data.frame ne contienne que des élément de même type (par exemple que des éléments de type numeric). vecForMat01 &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12) vecForMat02 &lt;- vecForMat01 * 10 vecForMat03 &lt;- vecForMat01 / 10 dfForMat &lt;- data.frame(vecForMat01, vecForMat02, vecForMat03) print(dfForMat) ## vecForMat01 vecForMat02 vecForMat03 ## 1 1 10 0.1 ## 2 2 20 0.2 ## 3 3 30 0.3 ## 4 4 40 0.4 ## 5 5 50 0.5 ## 6 6 60 0.6 ## 7 7 70 0.7 ## 8 8 80 0.8 ## 9 9 90 0.9 ## 10 10 100 1.0 ## 11 11 110 1.1 ## 12 12 120 1.2 is.matrix(dfForMat) ## [1] FALSE as.matrix(dfForMat) ## vecForMat01 vecForMat02 vecForMat03 ## [1,] 1 10 0.1 ## [2,] 2 20 0.2 ## [3,] 3 30 0.3 ## [4,] 4 40 0.4 ## [5,] 5 50 0.5 ## [6,] 6 60 0.6 ## [7,] 7 70 0.7 ## [8,] 8 80 0.8 ## [9,] 9 90 0.9 ## [10,] 10 100 1.0 ## [11,] 11 110 1.1 ## [12,] 12 120 1.2 is.matrix(as.matrix(dfForMat)) ## [1] TRUE Nous pouvons aussi créer une matrix à partir d’un vector avec la fonction as.matrix() (matrice de une seule colonne). as.matrix(vecForMat01) ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 ## [5,] 5 ## [6,] 6 ## [7,] 7 ## [8,] 8 ## [9,] 9 ## [10,] 10 ## [11,] 11 ## [12,] 12 8.4.2 Manipuler et faire des opérations sur une matrix Toutes les opérations terme à terme sont possibles sur les matrix. # opérations terme à terme miMat01 &lt;- matrix(vecForMat01, ncol = 3) miVecOp &lt;- c(1, 10, 100, 1000) miMat01 * miVecOp ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 20 60 100 ## [3,] 300 700 1100 ## [4,] 4000 8000 12000 miMat01 + miVecOp ## [,1] [,2] [,3] ## [1,] 2 6 10 ## [2,] 12 16 20 ## [3,] 103 107 111 ## [4,] 1004 1008 1012 miMat01 / miMat01 ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 1 1 1 ## [3,] 1 1 1 ## [4,] 1 1 1 miMat01 - 10 ## [,1] [,2] [,3] ## [1,] -9 -5 -1 ## [2,] -8 -4 0 ## [3,] -7 -3 1 ## [4,] -6 -2 2 Pour effectuer des opérations algébriques nous pouvons utiliser la fonction %*%. # opérations algébriques miVecConf &lt;- c(1, 10, 100) miMat01 %*% miVecConf ## [,1] ## [1,] 951 ## [2,] 1062 ## [3,] 1173 ## [4,] 1284 miMat02 &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), ncol = 3) print(miMat02) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 miMat02 %*% miMat02 ## [,1] [,2] [,3] ## [1,] 30 66 102 ## [2,] 36 81 126 ## [3,] 42 96 150 La diagonale d’une matrix peut être obtenue avec la fonction diag(), et le déterminant d’une matrix avec la fonction det(). print(miMat02) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 diag(miMat02) ## [1] 1 5 9 det(miMat02) ## [1] 0 Il est souvent utile de pouvoir tansposer une matrix (colonnes en lignes ou lignes en colonnes). Pour cela il existe les fonctions aperm() ou t(). la fonction t() est plus générique et fonctionne aussi sur les data.frame. aperm(miMat01) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 t(miMat01) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 8.4.3 Accèder aux éléments d’une matrix Comme pour un data.frame, nous pouvons accèder aux éléments d’une matrice en spécifiant un numéro de ligne et un numéro de colonne entre crochets simples [ ], et séparés par une virgule. Si i est le numéro de ligne et j le numéro de colonne, alors miMat01[i, j] renvoie l’élément situé à la ligne i et à la colonne j. miMat01[i, ] renvoie tous les éléments de la ligne i, et miMat01[, j] tous les éléments de la colonne j. Les sélections multiples sont possibles. Nous pouvons également accèder à un élément en fonction de sa position dans la matrice entre crochets simples [ ] en comptant par colonne puis par ligne. Dans notre exemple la valeur du dixième élément est 10. i &lt;- 2 j &lt;- 1 print(miMat01[i, j]) ## [1] 2 print(miMat01[i, ]) ## [1] 2 6 10 print(miMat01[, j]) ## [1] 1 2 3 4 print(miMat01[c(1, 2), c(2, 3)]) ## [,1] [,2] ## [1,] 5 9 ## [2,] 6 10 print(miMat01[10]) ## [1] 10 8.5 Le conteneur array Le conteneur de type array est une généralisation du conteneur de type matrix. Là où le type matrix a deux dimensions (les lignes et les colonnes), le type array a un nombre indéfini de dimensions. Nous pouvons connaître le nombre de dimensions d’un array (et donc d’une matrix) avec la fonction dim(). dim(miMat01) ## [1] 4 3 8.5.1 Créer un array La création d’un array est similaire à celle d’une matrix avec une dimension supplémentaire. miVecArr &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9) miArray &lt;- array(miVecArr, dim = c(3, 3, 2)) print(miArray) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 dim(miArray) ## [1] 3 3 2 is.array(miArray) ## [1] TRUE miVecArr02 &lt;- 10 * miVecArr miArray02 &lt;- array(c(miVecArr, miVecArr02), dim = c(3, 3, 2)) print(miArray02) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 10 40 70 ## [2,] 20 50 80 ## [3,] 30 60 90 dim(miArray02) ## [1] 3 3 2 is.array(miArray02) ## [1] TRUE Nous pouvons donner des noms aux lignes et aux colonnes, mais aussi aux éléments. miArray02 &lt;- array( c(miVecArr, miVecArr02), dim = c(3, 3, 2), dimnames = list( c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;), c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;), c(&quot;matrix1&quot;, &quot;matrix2&quot;) ) ) print(miArray02) ## , , matrix1 ## ## c1 c2 c3 ## r1 1 4 7 ## r2 2 5 8 ## r3 3 6 9 ## ## , , matrix2 ## ## c1 c2 c3 ## r1 10 40 70 ## r2 20 50 80 ## r3 30 60 90 8.5.2 Manipuler un array La manipulation d’un array se fait de la même façon que pour une matrix. pour accèder aux différents éléments d’un array, il suffit de spécifier la ligne i, la colonne j, et la matrix k. i &lt;- 2 j &lt;- 1 k &lt;- 1 print(miArray02[i, j, k]) ## [1] 2 print(miArray02[, j, k]) ## r1 r2 r3 ## 1 2 3 print(miArray02[i, , k]) ## c1 c2 c3 ## 2 5 8 print(miArray02[i, j, ]) ## matrix1 matrix2 ## 2 20 8.6 Conclusion Félicitations ! Nous connaissons à présent les principaux types d’objets que nous allons utiliser avec R. Un objet se caractérise par ses attributs : le type de conteneur (vector, data.frame, matrix, array) le type de contenu de chacun des éléments (numeric, logical, character, …) la valeur de chacun des éléments (5, “qwerty”, TRUE, …) Tous ces objets sont stockés temporairement dans l’environnement global de R (dans la RAM de notre ordinateur). Le prochain chapitre va traiter des fonctions, et mettra en lumière un des aspects qui rend R si puissant pour analyser et gérer nos données. "],
["fonctions.html", " 9 Les fonctions 9.1 Qu’est-ce qu’une fonction 9.2 Les fonctions les plus courantes 9.3 Autres fonctions utiles 9.4 Quelques exercices 9.5 Ecrire une fonction 9.6 Autres fonctions développées par la communauté des utilisateurs : les packages 9.7 Conclusion", " 9 Les fonctions 9.1 Qu’est-ce qu’une fonction Avec ce chapitre nous allons avoir un premier apperçu de la puissance de R grâce aux fonctions. Une fonction est un ensemble de lignes de code permettant d’exécuter une tâche particulière. Nous avons vu de nombreuses fonctions lors des précédents chapitres, la plus simple étant la fonction + permettant d’ajouter deux nombres entre eux, ou d’autres plus complexes comme c() ou data.frame() permettant de créer un vector ou un data.frame. Dans tous les cas une fonction se reconnait grâce aux parenthèses qui la suive dans laquelle nous allons renseigner des arguments. Les arguments correspondent aux informations que nous souhaitons transmettre à notre fonction pour qu’elle exécute la tâche que nous souhaitons réaliser. Pour les fonctions les plus simples comme +, les parenthèses ont été supprimés pour que le code soit plus facile à lire, mais il s’agit bien d’une fonction qui peut s’utiliser avec des parenthèses si nous utilisons le signe + entre guillemets. Les arguments sont les chiffres que nous souhaitons ajouter. 5 + 2 ## [1] 7 &#39;+&#39;(5, 2) ## [1] 7 Dans ce chapitre nous allons nous focaliser sur les fonctions les plus courantes de façon à ce que ce chapitre soit consultable comme un dictionnaire. Il ne s’agit donc pas de tout apprendre par coeur mais bien de savoir que ces fonctions existent et de pouvoir consulter ce chapitre plus tard comme référence. Avec le temps et la pratique nous finirons par les connaître par coeur ! Il y a plus de 1000 fonctions à ce jour dans la version de base de R, et plus de 10000 packages complémentaires pouvant être installés, chacun contenant plusieurs dizaines de fonctions. Avant de nous lancer dans l’écriture d’une nouvelle fonction, il faudra toujours vérifier qu’elle n’existe pas déjà. 9.2 Les fonctions les plus courantes Pour travailler avec les fonctions nous allons utiliser le jeu de données iris qui est inclu avec la version de base de R et qui correspond à la longeur et à la largeur des sépales et des pétales de différentes espèces d’iris. Le jeu de données est sous la forme d’un data.frame de 5 colonnes et de 150 lignes. Pour plus d’information sur le jeu de données iris nous pouvons consulter la documentation de R avec la fonction help(iris). L’accès à la documentation est l’objet de la section ci-dessous. 9.2.1 L’accès à la documentation 9.2.1.1 help() La fonction indispensable de R est celle permettant d’accèder à la documentation. Toutes les fonctions et tous les jeux de données de R possèdent une documentation. Nous pouvons accéder à la documentation avec la fonction help() ou en utilisant le raccourci ?. help(matrix) # équivalent à ?matrix La documentation est toujours structurée de la même manière. Tout d’abord nous avons le nom de la fonction recherchée matrix, suivie entre accolades par le nom du package R dont la fonction dépend. Nous verrons comment installer des packages additionnels plus tard. Pour l’instant nous disposons de ceux fournis avec la version de base de R. Ici nous pouvons voir que la fonction matrix() dépend du package base. Ensuite nous pouvons voir le libellé de la fonction (Matrices), suivi des paragraphes Description, Usage, et Arguments. Parfois vient s’ajouter les paragraphes Details, Note, References, et See also. Le dernier paragraphe est Examples. La dernière ligne de la documentation permet de revenir à l’index du package dont dépend la fonction consultée. En copiant collant help(matrix) dans notre console R, nous pouvons voir que le paragraphe Description indique ce que fait la fonction. Dans le cas de help(matrix), il y a trois fonctions qui sont présentées : matrix(), as.matrix(), et is.matrix(). # Description # matrix creates a matrix from the given set of values. # as.matrix attempts to turn its argument into a matrix. # is.matrix tests if its argument is a (strict) matrix. Le paragraphe Usage explique comment utiliser la fonction et quels sont les valeurs par défaut éventuelles pour chacun des paramètres. # Usage # matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, # dimnames = NULL) La fonction matrix() peut prendre 5 arguments : data, nrow, ncol, byrow, et dimnames. Nous pouvons voir que par défaut une matrix sera composée d’une seule ligne et d’une seule colonne, et que les informations serons renseignées par colonne. Le paragraphe Arguments détaille les valeurs et le type de conteneur de chacun des arguments de notre fonction. Par exemple nous pouvons voir que l’argument dimnames doit être de type list. C’est pouquoi nous avons utilisé ce format lors de la section sur les matrix. # Arguments # data an optional data vector (including a list or expression vector). # Non-atomic classed R objects are coerced by as.vector and all # attributes discarded. # nrow the desired number of rows. # ncol the desired number of columns. # byrow logical. If FALSE (the default) the matrix is filled by columns, # otherwise the matrix is filled by rows. # dimnames A dimnames attribute for the matrix: NULL or a list of length 2 # giving the row and column names respectively. An empty list is # treated as NULL, and a list of length one as row names. The # list can be named, and the list names will be used as names for # the dimensions. Le paragraphe Details apporte des éléments complémentaires sur la fonction. Le paragraphe Examples procure des exemples reproductibles dans la console. ## Example of setting row and column names mdat &lt;- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE, dimnames = list(c(&quot;row1&quot;, &quot;row2&quot;), c(&quot;C.1&quot;, &quot;C.2&quot;, &quot;C.3&quot;))) mdat ## C.1 C.2 C.3 ## row1 1 2 3 ## row2 11 12 13 Le nom des arguments n’est pas nécessaire pour qu’une fonction soit correctement interprété par R. Néanmoins par soucis de clarté il est préférable d’utiliser le nom des arguments suivi du signe = pour que le code soit plus lisible. # bon exemple mdat &lt;- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE) # mauvais exemple mdat &lt;- matrix(c(1,2,3, 11,12,13), 2, 3, TRUE) 9.2.1.2 help.search() La fonction help.search() ou ?? permet de rechercher une expression dans l’ensemble de la documentation. Elle est utile lorsque l’on cherche une fonctionnalité sans connaître le nom de la fonction sous R. help.search(&quot;average&quot;) La fonction help.search() renvoie vers une page contenant la liste des pages où l’expression a été retrouvée sous la forme nom-du-package::nom-de-la-fonction. 9.2.2 Visualiser les données 9.2.2.1 str() La fonction str() permet de visualiser la structure interne d’un objet, comme indiqué dans la documentation que nous pouvons consulter avec help(str). str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... La fonction str() renvoie le type d’objet (data.frame), le nombre d’observations (150), le nombre de variables (5), le nom de chacune des variables (Sepal.Length, Sepal.Width, Petal.Length, Petal.Width, et Species), le type de chacune des variables (num, Factor), et les premières valeurs de chacunes des variables. C’est une fonction utile pour avoir un apperçu d’un jeu de données, mais aussi pour contrôler que les données sont du type voulu avant de procéder à des analyses statistiques. 9.2.2.2 head() et tail() La fonction head() renvoie les premières valeurs d’un objet, et la fonction tail() les dernières valeurs d’un objet. Par défaut six valeurs sont retournées, l’argument n contrôle le nombre de valeurs à retourner. head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa tail(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica head(iris, n = 2) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa 9.2.2.3 names() Nous avons déjà vu la fonction names() qui permet à la fois de connaître le nom des éléments d’un objet, mais aussi d’assigner des noms aux éléments d’un objet comme une matrix, une list ou un data.frame. names(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; ## [5] &quot;Species&quot; irisCopy &lt;- iris names(irisCopy) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) names(irisCopy) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; 9.2.2.4 cat() et print() La fonction cat() permet d’afficher le contenu d’un objet alors que la fonction print() retourne la valeur d’un objet avec la possibilité d’effectuer des conversions. cat(names(iris)) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species print(names(iris)) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; ## [5] &quot;Species&quot; cat(iris[1, 1]) ## 5.1 print(iris[1, 1]) ## [1] 5.1 print(iris[1, 1], digits = 0) ## [1] 5 9.2.3 Manipuler les données 9.2.3.1 rank() La fonction rank() renvoie pour un ensemble d’éléments le numéro de la position de chacun des éléments. En cas d’éléments de même valeur, l’argument ties.method permet de faire un choix sur le classement. Comme pour toutes les fonctions, les détails sont présents dans la documentation. vecManip &lt;- c(10, 20, 30, 70, 60, 50, 40) rank(vecManip) ## [1] 1 2 3 7 6 5 4 vecManip2 &lt;- c(10, 20, 30, 10, 50, 10, 40) rank(vecManip2) ## [1] 2 4 5 2 7 2 6 rank(vecManip2, ties.method = &quot;first&quot;) ## [1] 1 4 5 2 7 3 6 rank(vecManip2, ties.method = &quot;min&quot;) ## [1] 1 4 5 1 7 1 6 print(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 ## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 ## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 ## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 ## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 ## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 ## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 ## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 rank(iris[, 1], ties.method = &quot;average&quot;) ## [1] 37.0 19.5 10.5 7.5 27.5 49.5 7.5 27.5 3.0 19.5 49.5 ## [12] 14.0 14.0 1.0 77.0 69.5 49.5 37.0 69.5 37.0 49.5 37.0 ## [23] 7.5 37.0 14.0 27.5 27.5 43.5 43.5 10.5 14.0 49.5 43.5 ## [34] 56.0 19.5 27.5 56.0 19.5 3.0 37.0 27.5 5.0 3.0 27.5 ## [45] 37.0 14.0 37.0 7.5 46.0 27.5 138.0 112.0 135.5 56.0 118.0 ## [56] 69.5 104.0 19.5 121.5 43.5 27.5 82.0 86.5 92.5 62.5 126.5 ## [67] 62.5 77.0 97.5 62.5 82.0 92.5 104.0 92.5 112.0 121.5 132.0 ## [78] 126.5 86.5 69.5 56.0 56.0 77.0 86.5 49.5 86.5 126.5 104.0 ## [89] 62.5 56.0 56.0 92.5 77.0 27.5 62.5 69.5 69.5 97.5 37.0 ## [100] 69.5 104.0 77.0 139.0 104.0 118.0 145.0 19.5 143.0 126.5 141.0 ## [111] 118.0 112.0 132.0 69.5 77.0 112.0 118.0 147.5 147.5 86.5 135.5 ## [122] 62.5 147.5 104.0 126.5 141.0 97.5 92.5 112.0 141.0 144.0 150.0 ## [133] 112.0 104.0 92.5 147.5 104.0 112.0 86.5 135.5 126.5 135.5 77.0 ## [144] 132.0 126.5 126.5 104.0 118.0 97.5 82.0 # help(rank) # ... # Usage # rank(x, na.last = TRUE, # ties.method = c(&quot;average&quot;, &quot;first&quot;, &quot;last&quot;, # &quot;random&quot;, &quot;max&quot;, &quot;min&quot;)) 9.2.3.2 order() La fonction order() retourne le numéro du réarrangement des éléments en focntion de leur position. Elle est très utile par exemple pour trier un data.frame en focntion d’une colonne. print(vecManip2) ## [1] 10 20 30 10 50 10 40 rank(vecManip2) ## [1] 2 4 5 2 7 2 6 order(vecManip2) ## [1] 1 4 6 2 3 7 5 print(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 ## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 ## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 ## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 ## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 ## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 ## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 ## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 rank(iris[, 1]) ## [1] 37.0 19.5 10.5 7.5 27.5 49.5 7.5 27.5 3.0 19.5 49.5 ## [12] 14.0 14.0 1.0 77.0 69.5 49.5 37.0 69.5 37.0 49.5 37.0 ## [23] 7.5 37.0 14.0 27.5 27.5 43.5 43.5 10.5 14.0 49.5 43.5 ## [34] 56.0 19.5 27.5 56.0 19.5 3.0 37.0 27.5 5.0 3.0 27.5 ## [45] 37.0 14.0 37.0 7.5 46.0 27.5 138.0 112.0 135.5 56.0 118.0 ## [56] 69.5 104.0 19.5 121.5 43.5 27.5 82.0 86.5 92.5 62.5 126.5 ## [67] 62.5 77.0 97.5 62.5 82.0 92.5 104.0 92.5 112.0 121.5 132.0 ## [78] 126.5 86.5 69.5 56.0 56.0 77.0 86.5 49.5 86.5 126.5 104.0 ## [89] 62.5 56.0 56.0 92.5 77.0 27.5 62.5 69.5 69.5 97.5 37.0 ## [100] 69.5 104.0 77.0 139.0 104.0 118.0 145.0 19.5 143.0 126.5 141.0 ## [111] 118.0 112.0 132.0 69.5 77.0 112.0 118.0 147.5 147.5 86.5 135.5 ## [122] 62.5 147.5 104.0 126.5 141.0 97.5 92.5 112.0 141.0 144.0 150.0 ## [133] 112.0 104.0 92.5 147.5 104.0 112.0 86.5 135.5 126.5 135.5 77.0 ## [144] 132.0 126.5 126.5 104.0 118.0 97.5 82.0 order(iris[, 1]) ## [1] 14 9 39 43 42 4 7 23 48 3 30 12 13 25 31 46 2 ## [18] 10 35 38 58 107 5 8 26 27 36 41 44 50 61 94 1 18 ## [35] 20 22 24 40 45 47 99 28 29 33 60 49 6 11 17 21 32 ## [52] 85 34 37 54 81 82 90 91 65 67 70 89 95 122 16 19 56 ## [69] 80 96 97 100 114 15 68 83 93 102 115 143 62 71 150 63 79 ## [86] 84 86 120 139 64 72 74 92 128 135 69 98 127 149 57 73 88 ## [103] 101 104 124 134 137 147 52 75 112 116 129 133 138 55 105 111 117 ## [120] 148 59 76 66 78 87 109 125 141 145 146 77 113 144 53 121 140 ## [137] 142 51 103 110 126 130 108 131 106 118 119 123 136 132 head(iris[order(iris[, 1]),], n = 10) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 14 4.3 3.0 1.1 0.1 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 39 4.4 3.0 1.3 0.2 setosa ## 43 4.4 3.2 1.3 0.2 setosa ## 42 4.5 2.3 1.3 0.3 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 23 4.6 3.6 1.0 0.2 setosa ## 48 4.6 3.2 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa 9.2.3.3 sort() La fonction sort() permet de trier les éléments d’un objet. Elle ne permet pas de trier selon plusieurs variables comme c’est le cas avec order(). print(vecManip2) ## [1] 10 20 30 10 50 10 40 sort(vecManip2) ## [1] 10 10 10 20 30 40 50 print(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 ## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 ## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 ## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 ## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 ## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 ## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 ## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 sort(iris[, 1]) ## [1] 4.3 4.4 4.4 4.4 4.5 4.6 4.6 4.6 4.6 4.7 4.7 4.8 4.8 4.8 4.8 4.8 4.9 ## [18] 4.9 4.9 4.9 4.9 4.9 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.1 5.1 ## [35] 5.1 5.1 5.1 5.1 5.1 5.1 5.1 5.2 5.2 5.2 5.2 5.3 5.4 5.4 5.4 5.4 5.4 ## [52] 5.4 5.5 5.5 5.5 5.5 5.5 5.5 5.5 5.6 5.6 5.6 5.6 5.6 5.6 5.7 5.7 5.7 ## [69] 5.7 5.7 5.7 5.7 5.7 5.8 5.8 5.8 5.8 5.8 5.8 5.8 5.9 5.9 5.9 6.0 6.0 ## [86] 6.0 6.0 6.0 6.0 6.1 6.1 6.1 6.1 6.1 6.1 6.2 6.2 6.2 6.2 6.3 6.3 6.3 ## [103] 6.3 6.3 6.3 6.3 6.3 6.3 6.4 6.4 6.4 6.4 6.4 6.4 6.4 6.5 6.5 6.5 6.5 ## [120] 6.5 6.6 6.6 6.7 6.7 6.7 6.7 6.7 6.7 6.7 6.7 6.8 6.8 6.8 6.9 6.9 6.9 ## [137] 6.9 7.0 7.1 7.2 7.2 7.2 7.3 7.4 7.6 7.7 7.7 7.7 7.7 7.9 9.2.3.4 append() Cette fonction permet d’ajouter un élément à un vector à une position déterminée par l’argument after. Cette fonction est aussi plus rapide que son alternative consistant à utiliser la fonction c(). print(vecManip2) ## [1] 10 20 30 10 50 10 40 append(vecManip2, 5) ## [1] 10 20 30 10 50 10 40 5 append(vecManip2, 5, after = 2) ## [1] 10 20 5 30 10 50 10 40 9.2.3.5 cbind() et rbind() Les fonctions cbind() et rbind() permettent de combiner des éléments par colonne ou par ligne. cbind(vecManip2, vecManip2) ## vecManip2 vecManip2 ## [1,] 10 10 ## [2,] 20 20 ## [3,] 30 30 ## [4,] 10 10 ## [5,] 50 50 ## [6,] 10 10 ## [7,] 40 40 rbind(vecManip2, vecManip2) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## vecManip2 10 20 30 10 50 10 40 ## vecManip2 10 20 30 10 50 10 40 9.2.3.6 paste() et paste0() Voilà deux fonctions que nous allons beaucoup utiliser par la suite. Les fonctions paste() et paste0() permettent de concaténer des chaines de caractère. La fonction paste0() est équivalente à paste() sans proposer de séparateur entre les éléments à concaténer. Elle est aussi plus rapide. paste(1, &quot;a&quot;) ## [1] &quot;1 a&quot; paste0(1, &quot;a&quot;) ## [1] &quot;1a&quot; paste(1, &quot;a&quot;, sep = &quot;_&quot;) ## [1] &quot;1_a&quot; paste0(&quot;prefix_&quot;, vecManip2, &quot;_suffix&quot;) ## [1] &quot;prefix_10_suffix&quot; &quot;prefix_20_suffix&quot; &quot;prefix_30_suffix&quot; ## [4] &quot;prefix_10_suffix&quot; &quot;prefix_50_suffix&quot; &quot;prefix_10_suffix&quot; ## [7] &quot;prefix_40_suffix&quot; paste(vecManip2, rank(vecManip2), sep = &quot;_&quot;) ## [1] &quot;10_2&quot; &quot;20_4&quot; &quot;30_5&quot; &quot;10_2&quot; &quot;50_7&quot; &quot;10_2&quot; &quot;40_6&quot; 9.2.3.7 rev() La fonction rev() renvoie les éléments d’un objet dans l’ordre inverse. print(vecManip2) ## [1] 10 20 30 10 50 10 40 rev(vecManip2) ## [1] 40 10 50 10 30 20 10 9.2.3.8 %in% La fonction %in% peut être assimilée à un opérateur de comparaison. Cette fonction prend deux objets comme arguments et renvoie TRUE ou FALSE pour chacun des éléments du premier objet en fonction de leur présence ou absence dans le second objet. Pour accéder à la documentation de la fonction, il faut utiliser des guillemets help('%in%'). print(vecManip) ## [1] 10 20 30 70 60 50 40 print(vecManip2) ## [1] 10 20 30 10 50 10 40 vecManip %in% vecManip2 ## [1] TRUE TRUE TRUE FALSE FALSE TRUE TRUE vecManip2 %in% vecManip ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE 9.2.4 Fonctions mathématiques Nous avons déjà vu les fonctions +, -, *, /, ^, %% et autres opérateurs arithmétiques. R possède également les fonctions mathématiques de base comme exponetielle exp(), racine carrée sqrt(), valeur absolue abs(), sinus sin(), cosinus cos(), tangente tan(), logarithme népérien log(), logarithme décimal log10(), arc cosinus acos(), arc sinus asin(), et arc tangente atan(). print(vecManip2) ## [1] 10 20 30 10 50 10 40 exp(vecManip2) ## [1] 2.202647e+04 4.851652e+08 1.068647e+13 2.202647e+04 5.184706e+21 ## [6] 2.202647e+04 2.353853e+17 sqrt(vecManip2) ## [1] 3.162278 4.472136 5.477226 3.162278 7.071068 3.162278 6.324555 abs(-vecManip2) ## [1] 10 20 30 10 50 10 40 sin(vecManip2) ## [1] -0.5440211 0.9129453 -0.9880316 -0.5440211 -0.2623749 -0.5440211 ## [7] 0.7451132 cos(vecManip2) ## [1] -0.8390715 0.4080821 0.1542514 -0.8390715 0.9649660 -0.8390715 ## [7] -0.6669381 tan(vecManip2) ## [1] 0.6483608 2.2371609 -6.4053312 0.6483608 -0.2719006 0.6483608 ## [7] -1.1172149 log(vecManip2) ## [1] 2.302585 2.995732 3.401197 2.302585 3.912023 2.302585 3.688879 log10(vecManip2) ## [1] 1.000000 1.301030 1.477121 1.000000 1.698970 1.000000 1.602060 acos(vecManip2/100) ## [1] 1.470629 1.369438 1.266104 1.470629 1.047198 1.470629 1.159279 asin(vecManip2/100) ## [1] 0.1001674 0.2013579 0.3046927 0.1001674 0.5235988 0.1001674 0.4115168 atan(vecManip2/100) ## [1] 0.09966865 0.19739556 0.29145679 0.09966865 0.46364761 0.09966865 ## [7] 0.38050638 9.2.5 Statistiques descriptives Nous pouvons également effectuer des statistiques descriptives très simplement à partir d’un jeu de données. 9.2.5.1 mean() La fonction mean() renvoie la moyenne. Pour ignorer les valeurs manquantes NA, il faut donner la valeur TRUE à l’argument na.rm(). mean(iris[, 1]) ## [1] 5.843333 vecManip3 &lt;- c(1, 5, 6, 8, NA, 45, NA, 14) mean(vecManip3) ## [1] NA mean(vecManip3, na.rm = TRUE) ## [1] 13.16667 9.2.5.2 sd() La fonction sd() renvoie l’écart type. sd(iris[, 1]) ## [1] 0.8280661 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 sd(vecManip3) ## [1] NA sd(vecManip3, na.rm = TRUE) ## [1] 16.16684 9.2.5.3 max() et min() La fonction max() renvoie la valeur maximale et min() la valeur minimale. max(iris[, 1]) ## [1] 7.9 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 max(vecManip3) ## [1] NA max(vecManip3, na.rm = TRUE) ## [1] 45 min(iris[, 1]) ## [1] 4.3 min(vecManip3) ## [1] NA min(vecManip3, na.rm = TRUE) ## [1] 1 9.2.5.4 quantile() La fonction quantile() renvoie le quantile défini par l’argument probs. quantile(iris[, 1]) ## 0% 25% 50% 75% 100% ## 4.3 5.1 5.8 6.4 7.9 quantile(iris[, 1], probs = c(0, 0.25, 0.5, 0.75, 1)) ## 0% 25% 50% 75% 100% ## 4.3 5.1 5.8 6.4 7.9 quantile(iris[, 1], probs = c(0, 0.1, 0.5, 0.9, 1)) ## 0% 10% 50% 90% 100% ## 4.3 4.8 5.8 6.9 7.9 9.2.5.5 summary() La fonction summary() renvoie un résumé composé du minimum, premier quartile, médiane, moyenne, troisième quartile et maximum. summary(iris[, 1]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.300 5.100 5.800 5.843 6.400 7.900 9.2.5.6 median() La fonction median() renvoie la médiane. median(iris[, 1]) ## [1] 5.8 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 median(vecManip3) ## [1] NA median(vecManip3, na.rm = TRUE) ## [1] 7 9.2.5.7 length() La fonction length() renvoie la taille d’un objet (nombre d’éléments). length(iris[, 1]) ## [1] 150 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 length(vecManip3) ## [1] 8 9.2.5.8 nrow() et ncol() La fonction nrow() renvoie le nombre de lignes et la fonction ncol() le nombre de colonnes d’un objet. nrow(iris) ## [1] 150 ncol(iris) ## [1] 5 9.2.5.9 round(), ceiling(), floor(), et trunc() La fonction round() permet de sélectionner un certain nombre de décimales (0 par défaut) round(5.56874258564) ## [1] 6 round(5.56874258564, digits = 2) ## [1] 5.57 La fonction ceiling() renvoie le plus petit nombre entier qui ne soit pas inférieure à la valeur rensignée. ceiling(5.9999) ## [1] 6 ceiling(5.0001) ## [1] 6 La fonction floor() renvoie le plus grand nombre entier qui ne soit pas supérieure à la valeur renseignée. floor(5.9999) ## [1] 5 floor(5.0001) ## [1] 5 La fonction trunc() renvoie la partie entière de la valeur rensignée. trunc(5.9999) ## [1] 5 trunc(5.0001) ## [1] 5 9.2.5.10 rowSums() et colSums() Les fonctions rowSums() et colSums() calculent la somme des lignes et des colonnes. rowSums(iris[, c(1, 2, 3, 4)]) ## [1] 10.2 9.5 9.4 9.4 10.2 11.4 9.7 10.1 8.9 9.6 10.8 10.0 9.3 8.5 ## [15] 11.2 12.0 11.0 10.3 11.5 10.7 10.7 10.7 9.4 10.6 10.3 9.8 10.4 10.4 ## [29] 10.2 9.7 9.7 10.7 10.9 11.3 9.7 9.6 10.5 10.0 8.9 10.2 10.1 8.4 ## [43] 9.1 10.7 11.2 9.5 10.7 9.4 10.7 9.9 16.3 15.6 16.4 13.1 15.4 14.3 ## [57] 15.9 11.6 15.4 13.2 11.5 14.6 13.2 15.1 13.4 15.6 14.6 13.6 14.4 13.1 ## [71] 15.7 14.2 15.2 14.8 14.9 15.4 15.8 16.4 14.9 12.8 12.8 12.6 13.6 15.4 ## [85] 14.4 15.5 16.0 14.3 14.0 13.3 13.7 15.1 13.6 11.6 13.8 14.1 14.1 14.7 ## [99] 11.7 13.9 18.1 15.5 18.1 16.6 17.5 19.3 13.6 18.3 16.8 19.4 16.8 16.3 ## [113] 17.4 15.2 16.1 17.2 16.8 20.4 19.5 14.7 18.1 15.3 19.2 15.7 17.8 18.2 ## [127] 15.6 15.8 16.9 17.6 18.2 20.1 17.0 15.7 15.7 19.1 17.7 16.8 15.6 17.5 ## [141] 17.8 17.4 15.5 18.2 18.2 17.2 15.7 16.7 17.3 15.8 colSums(iris[, c(1, 2, 3, 4)]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 876.5 458.6 563.7 179.9 9.2.5.11 rowMeans() et colMeans() Les fonctions rowMeans() et colMeans() calculent la moyenne des lignes et des colonnes. rowMeans(iris[, c(1, 2, 3, 4)]) ## [1] 2.550 2.375 2.350 2.350 2.550 2.850 2.425 2.525 2.225 2.400 2.700 ## [12] 2.500 2.325 2.125 2.800 3.000 2.750 2.575 2.875 2.675 2.675 2.675 ## [23] 2.350 2.650 2.575 2.450 2.600 2.600 2.550 2.425 2.425 2.675 2.725 ## [34] 2.825 2.425 2.400 2.625 2.500 2.225 2.550 2.525 2.100 2.275 2.675 ## [45] 2.800 2.375 2.675 2.350 2.675 2.475 4.075 3.900 4.100 3.275 3.850 ## [56] 3.575 3.975 2.900 3.850 3.300 2.875 3.650 3.300 3.775 3.350 3.900 ## [67] 3.650 3.400 3.600 3.275 3.925 3.550 3.800 3.700 3.725 3.850 3.950 ## [78] 4.100 3.725 3.200 3.200 3.150 3.400 3.850 3.600 3.875 4.000 3.575 ## [89] 3.500 3.325 3.425 3.775 3.400 2.900 3.450 3.525 3.525 3.675 2.925 ## [100] 3.475 4.525 3.875 4.525 4.150 4.375 4.825 3.400 4.575 4.200 4.850 ## [111] 4.200 4.075 4.350 3.800 4.025 4.300 4.200 5.100 4.875 3.675 4.525 ## [122] 3.825 4.800 3.925 4.450 4.550 3.900 3.950 4.225 4.400 4.550 5.025 ## [133] 4.250 3.925 3.925 4.775 4.425 4.200 3.900 4.375 4.450 4.350 3.875 ## [144] 4.550 4.550 4.300 3.925 4.175 4.325 3.950 colMeans(iris[, c(1, 2, 3, 4)]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 5.843333 3.057333 3.758000 1.199333 9.2.5.12 aggregate() La fonction aggregate() permet de grouper les éléments d’un objet en fonction d’une valeur. L’argument by définit l’élément sur lequel est effectué le regroupement. Il doit être de type list. aggregate(iris[, c(1, 2, 3, 4)], by = list(iris$Species), FUN = mean) ## Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 setosa 5.006 3.428 1.462 0.246 ## 2 versicolor 5.936 2.770 4.260 1.326 ## 3 virginica 6.588 2.974 5.552 2.026 aggregate(iris[, c(1, 2)], by = list(iris$Species), FUN = summary) ## Group.1 Sepal.Length.Min. Sepal.Length.1st Qu. Sepal.Length.Median ## 1 setosa 4.300 4.800 5.000 ## 2 versicolor 4.900 5.600 5.900 ## 3 virginica 4.900 6.225 6.500 ## Sepal.Length.Mean Sepal.Length.3rd Qu. Sepal.Length.Max. ## 1 5.006 5.200 5.800 ## 2 5.936 6.300 7.000 ## 3 6.588 6.900 7.900 ## Sepal.Width.Min. Sepal.Width.1st Qu. Sepal.Width.Median Sepal.Width.Mean ## 1 2.300 3.200 3.400 3.428 ## 2 2.000 2.525 2.800 2.770 ## 3 2.200 2.800 3.000 2.974 ## Sepal.Width.3rd Qu. Sepal.Width.Max. ## 1 3.675 4.400 ## 2 3.000 3.400 ## 3 3.175 3.800 9.2.5.13 range() La fonction range() renvoie le minimum et le maximum. range(iris[, 1]) ## [1] 4.3 7.9 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 range(vecManip3) ## [1] NA NA range(vecManip3, na.rm = TRUE) ## [1] 1 45 9.2.5.14 unique() La fonction unique() renvoie les valeurs uniques d’un objet (sans les doublons). unique(iris[, 1]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.4 4.8 4.3 5.8 5.7 5.2 5.5 4.5 5.3 7.0 6.4 ## [18] 6.9 6.5 6.3 6.6 5.9 6.0 6.1 5.6 6.7 6.2 6.8 7.1 7.6 7.3 7.2 7.7 7.4 ## [35] 7.9 print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 unique(vecManip3) ## [1] 1 5 6 8 NA 45 14 9.3 Autres fonctions utiles Nous ne pouvons aborder toutes les fonctions utiles, ici nous ne ferons qu’aborder certaines fonctions. Tout au long de ce livre de nouvelles fonctions seront utilisées. Lorsqu’une nouvelle fonction est utilisée, notre réflexe doit être toujours le même : consulter la documentation avec la fonction help(). 9.3.1 seq_along() La fonction seq_along() permet de créer un vector de la taille de l’objet renseigné et prenant comme valeurs les chiffres de 1 à N (N correspondant aux nombres d’éléments de l’objet). Cette fonction nous servira beaucoup lors du chapitre sur les boucles. print(vecManip3) ## [1] 1 5 6 8 NA 45 NA 14 seq_along(vecManip3) ## [1] 1 2 3 4 5 6 7 8 9.3.2 : La fonction : permet de créer une séquence de a à b par pas de 1, avec a et b le début et la fin de la séquence souhaitée. Il a été difficile d’écrire les chapitres précédents sans y avoir recours tant cette fonction est utile. Voici quelques exemples. 5:10 ## [1] 5 6 7 8 9 10 head(iris[, c(1, 2, 3, 4)]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 head(iris[, 1:4]) # ;-) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 miVec01 &lt;- c(1, 2, 3, 4) miVec01 &lt;- 1:4 # ;-) -10:12 ## [1] -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 ## [18] 7 8 9 10 11 12 5:-5 ## [1] 5 4 3 2 1 0 -1 -2 -3 -4 -5 paste(&quot;X&quot;, 1:10, sep = &quot;_&quot;) ## [1] &quot;X_1&quot; &quot;X_2&quot; &quot;X_3&quot; &quot;X_4&quot; &quot;X_5&quot; &quot;X_6&quot; &quot;X_7&quot; &quot;X_8&quot; &quot;X_9&quot; &quot;X_10&quot; 9.3.3 rep() La fonction rep() permet de répéter des éléments. miVec12 &lt;- c(1, 1, 1, 1, 1, 1, 1, 1, 1) miVec12 &lt;- rep(1, times = 9) # ;-) rep(&quot;Hola&quot;, times = 3) ## [1] &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; rep(1:3, time = 3) ## [1] 1 2 3 1 2 3 1 2 3 rep(1:3, length.out = 10) ## [1] 1 2 3 1 2 3 1 2 3 1 rep(1:3, each = 3) ## [1] 1 1 1 2 2 2 3 3 3 9.3.4 seq() La fonction seq() permet de créer une séquence personnalisée. seq(from = 0, to = 1, by = 0.2) ## [1] 0.0 0.2 0.4 0.6 0.8 1.0 seq(from = 20, to = 10, length.out = 10) ## [1] 20.00000 18.88889 17.77778 16.66667 15.55556 14.44444 13.33333 ## [8] 12.22222 11.11111 10.00000 letters[seq(from = 1, to = 26, by = 2)] ## [1] &quot;a&quot; &quot;c&quot; &quot;e&quot; &quot;g&quot; &quot;i&quot; &quot;k&quot; &quot;m&quot; &quot;o&quot; &quot;q&quot; &quot;s&quot; &quot;u&quot; &quot;w&quot; &quot;y&quot; rep(seq(from = 1, to = 2, by = 0.5), times = 3) ## [1] 1.0 1.5 2.0 1.0 1.5 2.0 1.0 1.5 2.0 9.3.5 getwd() La fonction getwd() définit le répertoire de travail. Cela correspond à l’endroit relatif à partir duquel R se positionne pour identifier les fichiers. Ce concept prendra son sens lorsque nous verrons comment importer et exporter des données. getwd() ## [1] &quot;/home/fr/myRBook_FR&quot; 9.3.6 setwd() La fonction setwd() permet de définir un nouveau répertoire de travail. oldWd &lt;- getwd() print(oldWd) ## [1] &quot;/home/fr/myRBook_FR&quot; setwd(&quot;..&quot;) getwd() ## [1] &quot;/home/fr&quot; setwd(oldWd) getwd() ## [1] &quot;/home/fr/myRBook_FR&quot; 9.3.7 list.files() La fonction list.files() permet de faire la liste de tous les fichiers présents dans le répertoire de travail. list.files(pattern = &quot;(html)$&quot;) # html ## [1] &quot;google_analytics_FR.html&quot; list.files(pattern = &quot;(pdf)$&quot;) # pdf ## character(0) 9.3.8 ls() Tout comme la fonction list.files() permet de faire la liste de tous les fichiers présents dans le répertoire de travail, la fonction ls() permet de faire la liste de tous les objets présents dans l’environnement de travail de R. ls() ## [1] &quot;aLogic&quot; &quot;bddInsect&quot; &quot;characters&quot; &quot;contrib&quot; ## [5] &quot;dfForMat&quot; &quot;factor01&quot; &quot;i&quot; &quot;irisCopy&quot; ## [9] &quot;j&quot; &quot;k&quot; &quot;logicals&quot; &quot;mdat&quot; ## [13] &quot;miArray&quot; &quot;miArray02&quot; &quot;miDf01&quot; &quot;miDfSub01&quot; ## [17] &quot;miDfSub02&quot; &quot;miDfSub03&quot; &quot;miDfSub04&quot; &quot;miList01&quot; ## [21] &quot;miList02&quot; &quot;miList0203&quot; &quot;miList03&quot; &quot;miList04&quot; ## [25] &quot;miList05&quot; &quot;miList06&quot; &quot;miMat&quot; &quot;miMat01&quot; ## [29] &quot;miMat02&quot; &quot;miVec01&quot; &quot;miVec02&quot; &quot;miVec03&quot; ## [33] &quot;miVec04&quot; &quot;miVec05&quot; &quot;miVec06&quot; &quot;miVec07&quot; ## [37] &quot;miVec08&quot; &quot;miVec09&quot; &quot;miVec10&quot; &quot;miVec11&quot; ## [41] &quot;miVec12&quot; &quot;miVec13&quot; &quot;miVec14&quot; &quot;miVec15&quot; ## [45] &quot;miVec20&quot; &quot;miVec21&quot; &quot;miVec22&quot; &quot;miVec23&quot; ## [49] &quot;miVec24&quot; &quot;miVec25&quot; &quot;miVecArr&quot; &quot;miVecArr02&quot; ## [53] &quot;miVecConf&quot; &quot;miVecNA&quot; &quot;miVecOp&quot; &quot;msg&quot; ## [57] &quot;myCol&quot; &quot;myRow&quot; &quot;myText&quot; &quot;myText2&quot; ## [61] &quot;myText3&quot; &quot;myText4&quot; &quot;myText5&quot; &quot;nbrRep&quot; ## [65] &quot;newVec&quot; &quot;newVec2&quot; &quot;numbers&quot; &quot;oldWd&quot; ## [69] &quot;opAriDf&quot; &quot;roundDou&quot; &quot;sumIntDou&quot; &quot;sumIntInt&quot; ## [73] &quot;terme01&quot; &quot;terme02&quot; &quot;vecForMat01&quot; &quot;vecForMat02&quot; ## [77] &quot;vecForMat03&quot; &quot;vecForMatrix&quot; &quot;vecManip&quot; &quot;vecManip2&quot; ## [81] &quot;vecManip3&quot; zzz &lt;- &quot;a new object&quot; ls() ## [1] &quot;aLogic&quot; &quot;bddInsect&quot; &quot;characters&quot; &quot;contrib&quot; ## [5] &quot;dfForMat&quot; &quot;factor01&quot; &quot;i&quot; &quot;irisCopy&quot; ## [9] &quot;j&quot; &quot;k&quot; &quot;logicals&quot; &quot;mdat&quot; ## [13] &quot;miArray&quot; &quot;miArray02&quot; &quot;miDf01&quot; &quot;miDfSub01&quot; ## [17] &quot;miDfSub02&quot; &quot;miDfSub03&quot; &quot;miDfSub04&quot; &quot;miList01&quot; ## [21] &quot;miList02&quot; &quot;miList0203&quot; &quot;miList03&quot; &quot;miList04&quot; ## [25] &quot;miList05&quot; &quot;miList06&quot; &quot;miMat&quot; &quot;miMat01&quot; ## [29] &quot;miMat02&quot; &quot;miVec01&quot; &quot;miVec02&quot; &quot;miVec03&quot; ## [33] &quot;miVec04&quot; &quot;miVec05&quot; &quot;miVec06&quot; &quot;miVec07&quot; ## [37] &quot;miVec08&quot; &quot;miVec09&quot; &quot;miVec10&quot; &quot;miVec11&quot; ## [41] &quot;miVec12&quot; &quot;miVec13&quot; &quot;miVec14&quot; &quot;miVec15&quot; ## [45] &quot;miVec20&quot; &quot;miVec21&quot; &quot;miVec22&quot; &quot;miVec23&quot; ## [49] &quot;miVec24&quot; &quot;miVec25&quot; &quot;miVecArr&quot; &quot;miVecArr02&quot; ## [53] &quot;miVecConf&quot; &quot;miVecNA&quot; &quot;miVecOp&quot; &quot;msg&quot; ## [57] &quot;myCol&quot; &quot;myRow&quot; &quot;myText&quot; &quot;myText2&quot; ## [61] &quot;myText3&quot; &quot;myText4&quot; &quot;myText5&quot; &quot;nbrRep&quot; ## [65] &quot;newVec&quot; &quot;newVec2&quot; &quot;numbers&quot; &quot;oldWd&quot; ## [69] &quot;opAriDf&quot; &quot;roundDou&quot; &quot;sumIntDou&quot; &quot;sumIntInt&quot; ## [73] &quot;terme01&quot; &quot;terme02&quot; &quot;vecForMat01&quot; &quot;vecForMat02&quot; ## [77] &quot;vecForMat03&quot; &quot;vecForMatrix&quot; &quot;vecManip&quot; &quot;vecManip2&quot; ## [81] &quot;vecManip3&quot; &quot;zzz&quot; 9.3.9 rm() La fonction rm() permet de supprimer un objet présent dans l’environnement de travail de R. rm(zzz) ls() ## [1] &quot;aLogic&quot; &quot;bddInsect&quot; &quot;characters&quot; &quot;contrib&quot; ## [5] &quot;dfForMat&quot; &quot;factor01&quot; &quot;i&quot; &quot;irisCopy&quot; ## [9] &quot;j&quot; &quot;k&quot; &quot;logicals&quot; &quot;mdat&quot; ## [13] &quot;miArray&quot; &quot;miArray02&quot; &quot;miDf01&quot; &quot;miDfSub01&quot; ## [17] &quot;miDfSub02&quot; &quot;miDfSub03&quot; &quot;miDfSub04&quot; &quot;miList01&quot; ## [21] &quot;miList02&quot; &quot;miList0203&quot; &quot;miList03&quot; &quot;miList04&quot; ## [25] &quot;miList05&quot; &quot;miList06&quot; &quot;miMat&quot; &quot;miMat01&quot; ## [29] &quot;miMat02&quot; &quot;miVec01&quot; &quot;miVec02&quot; &quot;miVec03&quot; ## [33] &quot;miVec04&quot; &quot;miVec05&quot; &quot;miVec06&quot; &quot;miVec07&quot; ## [37] &quot;miVec08&quot; &quot;miVec09&quot; &quot;miVec10&quot; &quot;miVec11&quot; ## [41] &quot;miVec12&quot; &quot;miVec13&quot; &quot;miVec14&quot; &quot;miVec15&quot; ## [45] &quot;miVec20&quot; &quot;miVec21&quot; &quot;miVec22&quot; &quot;miVec23&quot; ## [49] &quot;miVec24&quot; &quot;miVec25&quot; &quot;miVecArr&quot; &quot;miVecArr02&quot; ## [53] &quot;miVecConf&quot; &quot;miVecNA&quot; &quot;miVecOp&quot; &quot;msg&quot; ## [57] &quot;myCol&quot; &quot;myRow&quot; &quot;myText&quot; &quot;myText2&quot; ## [61] &quot;myText3&quot; &quot;myText4&quot; &quot;myText5&quot; &quot;nbrRep&quot; ## [65] &quot;newVec&quot; &quot;newVec2&quot; &quot;numbers&quot; &quot;oldWd&quot; ## [69] &quot;opAriDf&quot; &quot;roundDou&quot; &quot;sumIntDou&quot; &quot;sumIntInt&quot; ## [73] &quot;terme01&quot; &quot;terme02&quot; &quot;vecForMat01&quot; &quot;vecForMat02&quot; ## [77] &quot;vecForMat03&quot; &quot;vecForMatrix&quot; &quot;vecManip&quot; &quot;vecManip2&quot; ## [81] &quot;vecManip3&quot; 9.4 Quelques exercices Voici quelques exercices pour se perfectionner dans l’usage des fonctions et en apprendre de nouvelles grâce à la documentation. Certains exercices sont difficiles, nous pourrons y revenir plus tard. 9.4.1 Séquences 9.4.1.1 Reproduisons les séquences suivantes : -3 -4 -5 -6 -7 -8 -9 -10 –11 -3 -1 1 3 5 7 9 11 3.0 3.2 3.4 3.6 3.8 4.0 20 18 16 14 12 10 8 6 “a” “f” “k” “p” “u” “z” “a” “a” “a” “a” “a” “f” “f” “f” “f” “f” “k” “k” “k” “k” “k” “p” “p” “p” “p” “p” “u” “u” “u” “u” “u” “z” “z” “z” “z” “z” 9.4.1.2 Solutions possibles (car il y a toujours plusieurs solutions) : -3:-11 ## [1] -3 -4 -5 -6 -7 -8 -9 -10 -11 seq(from = -3, to = 11, by = 2) ## [1] -3 -1 1 3 5 7 9 11 seq(from = 3.0, to = 4.0, by = 0.2) ## [1] 3.0 3.2 3.4 3.6 3.8 4.0 letters[seq(from = 1, to = 26, by = 5)] ## [1] &quot;a&quot; &quot;f&quot; &quot;k&quot; &quot;p&quot; &quot;u&quot; &quot;z&quot; letters[rep(seq(from = 1, to = 26, by = 5), each = 5)] ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;k&quot; &quot;k&quot; &quot;k&quot; &quot;k&quot; &quot;k&quot; &quot;p&quot; &quot;p&quot; ## [18] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;u&quot; &quot;u&quot; &quot;u&quot; &quot;u&quot; &quot;u&quot; &quot;z&quot; &quot;z&quot; &quot;z&quot; &quot;z&quot; &quot;z&quot; 9.4.2 Statistiques descriptives Dans le jeu de données iris, combien de valeurs de largeur de sépales sont supérieures à 3 ? Entre 2.8 et 3.2 ? Comment peut-on visualiser la distribution des données (fonction table()) ? Quelles sont les 10 valeurs les plus petites ? Comment calculer un intervalle contenant 90% des valeurs ? Si la distribution des données était Normale, quelle serait la valeur théorique de cet intervalle de 90% (fonction qnorm()) ? Solutions : length(iris$Sepal.Width[iris$Sepal.Width &gt; 3]) ## [1] 67 length(iris$Sepal.Width[iris$Sepal.Width &gt; 2.8 &amp; iris$Sepal.Width &lt; 3.2]) ## [1] 47 table(iris$Sepal.Width) ## ## 2 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 ## 1 3 4 3 8 5 9 14 10 26 11 13 6 12 6 4 3 6 ## 3.9 4 4.1 4.2 4.4 ## 2 1 1 1 1 table(round(iris$Sepal.Width)) ## ## 2 3 4 ## 19 106 25 irisSepWCopy &lt;- iris$Sepal.Width irisSepWCopy &lt;- irisSepWCopy[order(irisSepWCopy)] head(irisSepWCopy, n = 10) ## [1] 2.0 2.2 2.2 2.2 2.3 2.3 2.3 2.3 2.4 2.4 quantile(irisSepWCopy, probs = c(0.05, 0.95)) ## 5% 95% ## 2.345 3.800 qnorm( p = c(0.05, 0.95), mean = mean(irisSepWCopy), sd = sd(irisSepWCopy) ) ## [1] 2.340397 3.774270 9.5 Ecrire une fonction Lorsque nous reproduisons plusieurs fois les mêmes opérations, le code devient fastidieux à écrire, et plus difficile à maintenir car si nous devons effectuer une modification, il faudra la répéter chaque fois que nous l’avons utilisée. C’est un signe indiquant la nécesité de recourir à une fonction. Dans l’exemple qui suit, il est fastidieux de modifier le code si nous souhaitons ajouter +45 au lieu de +20 à chaque ligne. 35 + 20 ## [1] 55 758 + 20 ## [1] 778 862 + 20 ## [1] 882 782 + 20 ## [1] 802 Comme pour les fonctions de base de R, nos fonction vont avoir un nom, et des arguments. Comme pour les noms des objets et les noms des fichiers, il est important de bien choisir le nom de notre fonction (cf. section sur les objets). Pour créer une fonction nous allons utiliser la fonction function() qui prend comme arguments les arguments de notre fonction. La fonction va retourner le résultat souhaité. Par défaut le résultat renvoyé est le dernier utilisé, mais il est préférable de l’expliciter avec la fonction return(). La fonction suivante addX prend comme argument x et renvoie x + 20. addX &lt;- function(x){ return(x + 20) } Notre code devient : addX(35) ## [1] 55 addX(758) ## [1] 778 addX(862) ## [1] 882 addX(782) ## [1] 802 Si nous souhaitons modifier le code pour ajouter 45 plutôt que 20, il suffit alors de modifier la fonction addX(). addX &lt;- function(x){ return(x + 45) } addX(35) ## [1] 80 addX(758) ## [1] 803 addX(862) ## [1] 907 addX(782) ## [1] 827 Ici nous aurions pu utiliser le format vector pour éviter les répétitions, mais ce n’est pas toujours possible. c(35, 758, 862, 782) + 20 ## [1] 55 778 882 802 Voyons cette fonction qui va compter le nombre de consonnes et de voyelles en minuscule dans un mot. Tout d’abord nous allons séparer toutes les lettres avec la fonction strsplit (nous pouvons consulter l’aide pour en savoir plus sur cette fonction). Ensuite nous allons compter les voyelles et les consonnes avec la fonction length(). Pour avoir la liste des lettres nous allons utiliser la constante letters (consulter l’aide). countVowelConso &lt;- function(word){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- length(wordSplit[wordSplit %in% vowels]) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- length(wordSplit[wordSplit %in% consonants]) return(c(numVowel, numConso)) } Nous pouvons maintenant utiliser notre fonction. countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] 11 9 Cette fonction peut être modifiée en affichant un message plus explicite. Même si en général ce genre de message est à éviter pour ne pas surcharger les fonctions, il peut être utile pour vérifier que tout se déroule correctement (nous le supprimerons ensuite). countVowelConso &lt;- function(word){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- length(wordSplit[wordSplit %in% vowels]) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- length(wordSplit[wordSplit %in% consonants]) print(paste0(&quot;Il y a &quot;, numVowel, &quot; voyelles et &quot;, numConso, &quot; consonnes dans le mot &#39;&quot;, word, &quot;&#39;.&quot;)) return(c(numVowel, numConso)) } countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] &quot;Il y a 11 voyelles et 9 consonnes dans le mot &#39;qwertyuiop azertyuiop&#39;.&quot; ## [1] 11 9 Par contre si nous utilisons countVowelConso(word = 5), une erreur va être renvoyée car notre fonction attend un objet de type character. De manière générale il est recommandée de gérer les erreurs renvoyées par nos fonctions afin que notre code soit plus facile à débogger. Ici nous allons simplement vérifier que l’argument est de type character, dans un vector de taille 1. Nous allons aussi commenter notre fonction pour rapidement retrouver ce qu’elle réalise (commentaire inséré sur la première ligne, que l’on retrouve aussi parfois sur la dernière ligne des fonctions). countVowelConso &lt;- function(word){ # compte les voyelles et les consonnes if(is.vector(word) &amp; is.character(word) &amp; length(word) == 1){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- length(wordSplit[wordSplit %in% vowels]) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- length(wordSplit[wordSplit %in% consonants]) return(c(numVowel, numConso)) } else { print(paste0(&quot;Erreur dans la fonction countVowelConso, &quot;, &quot;argument &#39;word&#39; incorrect (&quot;, word, &quot;)&quot;)) } } countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] 11 9 countVowelConso(word = 5) ## [1] &quot;Erreur dans la fonction countVowelConso, argument &#39;word&#39; incorrect (5)&quot; Avec R comme pour tout langage de programmation, pour un problème il existe toujours de multiples solutions. Nous nous souvenons de la section sur les types de données (type de données logical), ainsi que de la section sur les opérateurs de comparaison que la valeur de TRUE est de 1 et la valeur de FALSE est de 0. Nous venons de voir ci-dessus que la fonction %in% renvoie TRUE ou FALSE pour chacun des éléments du premier objet en fonction de leur présence ou absence dans le second objet. Notre fonction aurait pu donc se passer de la fonction length() pour le comptage des voyelles et des consonnes et utiliser la fonction sum(). countVowelConsoAlt &lt;- function(word){ # compte les voyelles et les consonnes if(is.vector(word) &amp; is.character(word) &amp; length(word) == 1){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- sum(wordSplit %in% vowels) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- sum(wordSplit %in% consonants) return(c(numVowel, numConso)) } else { print(paste0(&quot;Erreur dans la fonction countVowelConso, &quot;, &quot;argument &#39;word&#39; incorrect (&quot;, word, &quot;)&quot;)) } } countVowelConsoAlt(word = &quot;qwertyuiop azertyuiop&quot;) ## [1] 11 9 Il n’y a pas de solution optimale dans l’absolu, tout dépend des objectifs recherchés. La première solution est peut être plus facile à comprendre, et la seconde peut être plus rapide en terme de vitesse d’exécution (même en répétant l’utilisation de la fonction 10000 fois, le gain de temps est presque nul dans notre cas). system.time(replicate(n = 10000, countVowelConso(word = &quot;qwertyuiop azertyuiop&quot;))) ## user system elapsed ## 0.139 0.000 0.138 system.time(replicate(n = 10000, countVowelConsoAlt(word = &quot;qwertyuiop azertyuiop&quot;))) ## user system elapsed ## 0.118 0.000 0.118 Une fonction peut avoir des valeurs par défaut pour ses arguments. C’est le cas de la plupart des fonctions existantes. Par défaut, notre fonction va désormais compter le nombre de voyelles et de consonnes dans le mot qwerty (les parenthèses restent nécessaires même en l’absence d’arguments). countVowelConsoAlt &lt;- function(word = &quot;qwerty&quot;){ # compte les voyelles et les consonnes if(is.vector(word) &amp; is.character(word) &amp; length(word) == 1){ wordSplit &lt;- strsplit(word, split = &quot;&quot;)[[1]] vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;y&quot;) numVowel &lt;- sum(wordSplit %in% vowels) consonants &lt;- letters[!letters %in% vowels] numConso &lt;- sum(wordSplit %in% consonants) return(c(numVowel, numConso)) } else { print(paste0(&quot;Erreur dans la fonction countVowelConso, &quot;, &quot;argument &#39;word&#39; incorrect (&quot;, word, &quot;)&quot;)) } } countVowelConsoAlt() ## [1] 2 4 R compte de nombreuses fonctions, donc avant de vous lancer dans l’écriture d’une nouvelle fonction, il faut toujours vérifier que celle-ci n’existe pas déjà soit dans la version de base de R, soit dans des packages développés par la communauté des utilisateurs. Pour cela nous pouvons utiliser l’aide et la fonction ??, mais aussi notre navigateur Internet. 9.6 Autres fonctions développées par la communauté des utilisateurs : les packages Un package est un ensemble de fichiers que l’on va ajouter à R pour pouvoir utiliser des fonctions (ou des jeux de données) que d’autres personnes ont développés. Il ya à ce jour plus de 10000 packages sur les serveurs de R (CRAN ; https://cran.r-project.org/web/packages/), plus de 1000 sur les serveurs de BioConductor (pour l’analyse génomique), et plusieurs centaines sur GitHub. Chaque package permet de mettre à disposition des fonctions pour à peu près tout faire… Il peut donc être difficile de trouver le package adapté à ce que nous souhaitons réaliser, et il est important de consacrer du temps sa recherche, et de tester plusieurs solutions. Pour utiliser un package il nous faut tout d’abord l’installer, puis le charger dans notre session de R. 9.6.1 Installer un package Une fois notre package sélectionné, nous pouvons le télécharger et l’installer avec la fonction install.packages() qui prend comme argument le nom du package entre guillemets (la fonction tolère l’absence de guillemets mais il est préférable de les utiliser pour que le code soit plus lisible). Certains packages sont installés par défault avec R, c’est le cas par exemple de stats (qui est aussi chargé par défaut). install.packages(&quot;stats&quot;) # R statistical functions L’installation d’un package est à réaliser une seule fois, ensuite le package est sur notre ordinateur. 9.6.2 Charger un package Pour pouvoir utiliser les fonctions d’un package, nous devons le charger dans notre session de R. Il y a tellement de packages disponibles que R ne va pas charger par défault tous ceux que nous avons installé, mais seulement ceux dont nous allons avoir besoin pour notre étude en cours. Pour charger un package nous utilisons la fonction library(). library(&quot;stats&quot;) Le chargement du package est à réaliser à chaque fois que nous souhaitons exécuter notre code, il fait donc partie intégrante de notre script. 9.6.3 Portabilité du code Nous venons de voir que l’installation d’un package est à faire une seule fois par ordinateur, et que par contre le chargement d’un package est à réaliser pour chaque nouvelle session de R. Si l’on change d’ordinateur ou si l’on partage un script avec un collègue, il peut donc y avoir des erreurs à l’exécution liées à l’absence de l’installation d’un package. Pour pallier à ce problème, il est recommandé d’utiliser une fonction qui va vérifier si les packages nécessaires à l’exécution d’un script sont installés, si besoin les installer, puis les charger. Il existe de nombreuses fonctions pour faire cela sur Internet. La solution que nous proposons ici est un mélange adapté de différentes sources. Il n’est pas nécessaire de comprendre les détails de ce script pour le moment, mais simplement de comprendre ce qu’il fait. Voici un exemple pour les packages stats et graphics qui sont deux packages déjà présents avec la version de base de R, mais nous pouvons essayer avec tous les packages disponibles sur le CRAN, dont la liste se trouve ici : https://cran.r-project.org/web/packages/available_packages_by_name.html. pkgCheck &lt;- function(packages){ for(x in packages){ try(if(!require(x, character.only = TRUE)){ install.packages(x, dependencies = TRUE) if(!require(x, character.only = TRUE)){ stop() } }) } } pkgCheck(c(&quot;stats&quot;, &quot;graphics&quot;)) Alternativement nous pouvons utiliser la fonction .packages() pour lister les packages disponibles sur le CRAN par ordre alphabétique. head(.packages(all.available = TRUE), n = 30) ## [1] &quot;backports&quot; &quot;base64enc&quot; &quot;bitops&quot; &quot;bookdown&quot; &quot;caTools&quot; ## [6] &quot;curl&quot; &quot;devtools&quot; &quot;digest&quot; &quot;evaluate&quot; &quot;git2r&quot; ## [11] &quot;glue&quot; &quot;highr&quot; &quot;htmltools&quot; &quot;httr&quot; &quot;jsonlite&quot; ## [16] &quot;knitr&quot; &quot;magrittr&quot; &quot;markdown&quot; &quot;memoise&quot; &quot;mime&quot; ## [21] &quot;openssl&quot; &quot;R6&quot; &quot;Rcpp&quot; &quot;rmarkdown&quot; &quot;rprojroot&quot; ## [26] &quot;rstudioapi&quot; &quot;stringi&quot; &quot;stringr&quot; &quot;tinytex&quot; &quot;whisker&quot; La fonction pkgCheck() assure la portabilité de nos scripts : ils fonctionneront sur tous les ordinateurs sans avoir à effectuer de modification. Ainsi nos scipts pourront par exemple être joints à nos articles scientifiques et assurer ainsi la reproductibilité de nos résultats. 9.7 Conclusion Félicitations ! Nous savons à présent ce qu’est une fonction, comment chercher de l’aide sur une fonction, et même écrire ses propres fonctions. Nous savons aussi qu’il existe de nombreuses fonctions développées par la communauté des utilisateurs de R au sein de packages que nous savons installer et charger, et s’assurer de la portabilité de nos script d’un ordinateur à un autre (important pour la reproductibilité des résultats). Le prochain chapitre va s’intéresser à la lecture et à l’écriture de fichiers car bien souvent, nos données sont sur des fichiers de texte ou de tableurs. "],
["import.html", " 10 Importer et exporter des données 10.1 Lire des données depuis un fichier 10.2 Exporter ou charger des données pour R 10.3 Exporter des données 10.4 Conclusion", " 10 Importer et exporter des données 10.1 Lire des données depuis un fichier 10.1.1 Transformer ses données au format TXT ou CSV Il existe de nombreuses façons de lire le contenu d’un fichier avec R. Cependant nous nous focaliserons sur la lecture des fichiers TXT et CSV qui sont les plus communs et les plus fiables. A de rares exceptions près tous les fichiers de données peuvent très facilement être transformés aux formats TXT et CSV. C’est la pratique à préférer pour une analyse des données avec R. Concrètement, depuis Microsoft Excel, il suffit d’aller dans Fichier, puis Enregistrer sous, de sélectionner l’endroit où nous souhaitons sauvegarder notre fichier (cf. chapitre suivant sur la gestion d’un projet R) puis dans la fenêtre de sauvegarde changer le Type depuis XLSX vers CSV. Depuis LibreOffice Calc, il suffit d’aller dans Fichier, puis Enregistrer sous, puis de sélectionner le Type CSV. Il est important de savoir que le fichier CSV ne supporte pas la mise en forme des fichiers tableurs avec par exemple des couleurs, et que le fichier CSV ne contient qu’un seul onglet. Si nous avons un fichier tableur avec plusieurs onglets, il faudra sauvegarder autant de fichiers CSV que d’onglets. CSV vient de l’anglais Comma-separated values (https://fr.wikipedia.org/wiki/Comma-separated_values), et représente des données de tableur au format texte séparées par des virgules (ou des points virgules suivant les pays). Un fichier CSV pourra toujours s’ouvrir avec notre logiciel de tableur, mais aussi avec un simple éditeur de texte comme le bloc notes de Windows ou encore avec Notepad++. Il est d’ailleurs préférables d’ouvrir les fichiers CSV avec un éditeur de texte car les tableurs ont la facheuse tendance à vouloir modifier automatiquement les fichiers CSV et cela a pour conséquence de les rendre difficiles à lire. Une fois le fichier TXT ou CSV obtenu, la lecture du contenu depuis R est facile, même si elle demande un peu de rigueur. 10.1.2 Lire un fichier CSV C’est la source d’erreur la plus commune chez les débutants en R. C’est pourquoi il est important de lire et de relire ce chapitre et celui sur la gestion d’un projet R avec beaucoup d’attention. Commençons par préciser que R travaille dans un répertoire défini par défaut. Les utilisateurs de Rstudio ou autre environnement de développement spécialisés pour R seront tenter d’utiliser les options disponibles via les menus pour définir leur répertoire de travail ou pour charger le contenu d’un fichier. Dans ce livre ces techniques ne seront jamais utilisées car elles ne permettent pas la reproductibilité des résultats. Un script doit toujours pouvoir fonctionner pour tous les systèmes d’exploitation et quel que soit l’environnement de développement de l’utilisateur. Le répertoire de travail par défaut peut être obtenu avec la fonction getwd() et spécifier avec la fonction setwd(). oldWd &lt;- getwd() print(oldWd) ## [1] &quot;/home/fr/myRBook_FR&quot; setwd(&quot;..&quot;) getwd() ## [1] &quot;/home/fr&quot; setwd(oldWd) getwd() ## [1] &quot;/home/fr/myRBook_FR&quot; Nous avons donc quatre options : nous pouvons lire le contenu d’un fichier en indiquant à R son chemin complet (à proscrire pour la reproductibilité des résultats) nous pouvons lire le contenu d’un fichier en indiquant à R son chemin relatif nous pouvons déplacer le fichier dans le répertoire de travail de R nous pouvons modifier le répertoire de travail de R pour qu’il corresponde à l’emplacement de notre fichier (avec son chemin relatif) Un exemple de chemin complet serait : /home/myName/myFile.csv sous un environnement UNIX C:/users/myName/myFile.csv sous un environnement Windows (attention, sous R nous utilisons / et non pas \\ comme c’est le cas par défaut sous Windows) Un chemin relatif serait : myName/myFiles.csv Pour naviguer dans les chemins relatifs nous pouvons utiliser .. qui permet de remonter dans le répertoire source. Par exemple si le répertoire de travail est myScripts et que l’arborescence de mes fichiers est ainsi : ## -myProject ## |-myFiles ## |-|-data01.csv ## |-|-data02.csv ## |-myScripts ## |-|-myFirstScript.R Le chemin relatif vers le fichier data01.csv serait ../myFiles/data01.csv Donc pour lire le contenu du fichier data01.csv, nous allons privilégier l’option 2 (lire le contenu d’un fichier en indiquant à R son chemin relatif) ou l’option 4 (modifier le répertoire de travail de R pour qu’il corresponde à l’emplacement de notre fichier). Dans ce dernier cas : myWD &lt;- &quot;../myFiles/&quot; setwd(myWd) getwd() # pour verifier que nous sommes dans le bon repertoire list.files() # pour verifier que le fichier se trouve bien ici L’erreur la plus commune : ## Error in setwd(&quot;../myFiles/&quot;) : ## impossible de changer de répertoire de travail Cela veut dire que le répertoire n’existe pas (il faut vérifier que la syntaxe est correcte et que le répertoire existe bien avec ce chemin). Une fois le répertoire de travail correctement défini ou le chemin relatif vers le fichier correctement établi, nous pouvons lire le fichier avec la fonction read.table(). Certains utilisent la fonction read.csv() mais ce n’est qu’un cas particulier de la fonction read.table(). myWD &lt;- &quot;../myFiles/&quot; setwd(myWd) read.table(file = &quot;data01.csv&quot;) ou alternativement : read.table(file = &quot;../myFiles/data01.csv&quot;) Si le chemin n’est pas correctement renseigné ou si le fichier de données n’existe pas, R renverra l’erreur suivante : ## Error in file(file, &quot;rt&quot;) : impossible d&#39;ouvrir la connexion ## De plus : Warning message: ## In file(file, &quot;rt&quot;) : ## impossible d&#39;ouvrir le fichier &#39;../myFiles/data01.csv&#39; : No such file or directory Si tout va bien, R affiche le contenu du fichier data01.csv. Attention aux utilisateurs de Windows car par défaut le nom des fichier apparaît sans leur extension… Ainsi lorsque nous navigons dans les répertoires avec l’explorateur de fichiers, il n’y a pas de fichier data01.csv mais uniquement un fichier data01. Il est indispensable de remedier à ce problème pour éviter les erreurs. Pour ce faire il suffit d’ouvrir les ‘Options de l’Explorateur de fichiers’ via la touche ‘Windows’, puis dans l’onglet ‘Affichage’, de vérifier que l’option ‘Masquer les extensions des fichiers dont le type est connu’ est bien décochée. En consultant l’aide sur la fonction read.table(), nous puvons voir qu’elle possède de nombreux arguments. Les principaux sont les suivants : header = FALSE : est-ce que le fichier contient des noms de colonnes ? Si oui alors il faut changer la valeur pour header = TRUE sep = &quot;&quot; : comment sont séparées les données de la table ? Dans un fichier CSV il s’agit de la virgule ou du point virgule, donc à changer pour sep = &quot;,&quot; ou sep = &quot;;&quot; dec = &quot;.&quot; : quel est le séparateur des nombres décimaux ? Si c’est la virgule alors il faut changer pour dec = &quot;,&quot; Avec ces trois arguments la plupart des fichiers pourront être lus sans aucun problème. En cas de besoin l’aide est faite pour être consultée, et elle est très complète. La fonction read.table() renvoie le contenu du fichier sous forme d’une data.frame. Pour pouvoir utiliser le contenu du fichier nous allons donc stocker la data.frame dans un objet. myWD &lt;- &quot;../myFiles/&quot; setwd(myWd) data01 &lt;- read.table(file = &quot;data01.csv&quot;) str(data01) # verifier format des donnees head(data01) # verifier les premieres donnees L’étude de cas sur l’analyse de données de dataloggers se base sur un fichier CSV. En voici un extrait : bdd &lt;- read.table(&quot;myFiles/E05C13.csv&quot;, skip = 1, header = TRUE, sep = &quot;,&quot;, dec = &quot;.&quot;, stringsAsFactors = FALSE) colnames(bdd) &lt;- c(&quot;id&quot;, &quot;date&quot;, &quot;temp&quot;) head(bdd) ## id date temp ## 1 1 11/12/15 23:00:00 4.973 ## 2 2 11/12/15 23:30:00 4.766 ## 3 3 11/13/15 00:00:00 4.844 ## 4 4 11/13/15 00:30:00 4.844 ## 5 5 11/13/15 01:00:00 5.076 ## 6 6 11/13/15 01:30:00 5.282 tail(bdd) ## id date temp ## 32781 32781 09/25/17 21:00:00 7.091 ## 32782 32782 09/25/17 21:30:00 6.914 ## 32783 32783 09/25/17 22:00:00 6.813 ## 32784 32784 09/25/17 22:30:00 6.611 ## 32785 32785 09/25/17 23:00:00 6.331 ## 32786 32786 09/25/17 23:30:00 5.385 str(bdd) ## &#39;data.frame&#39;: 32786 obs. of 3 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ date: chr &quot;11/12/15 23:00:00&quot; &quot;11/12/15 23:30:00&quot; &quot;11/13/15 00:00:00&quot; &quot;11/13/15 00:30:00&quot; ... ## $ temp: num 4.97 4.77 4.84 4.84 5.08 ... 10.1.3 Lire un fichier texte La fonction la plus simple pour lire un fichier contenant du texte est readlines(). Voici un exemple avec le fichier README.md de ce livre, que l’on retrouve sur GitHub. readmeGitHub &lt;- &quot;https://raw.githubusercontent.com/frareb/myRBook_FR/master/README.md&quot; readLines(readmeGitHub) ## [1] &quot;# myRBook_FR&quot; ## [2] &quot;Vous trouverez ici le code source du livre *Se former au logiciel R : initiation et perfectionnement*, construit avec bookdown.&quot; Il existe aussi la fonction scan() qui va renvoyer l’ensemble des mots séparés par des espaces. Nous pouvons consulter l’aide pour plus d’information. scan(readmeGitHub, what = &quot;character&quot;) ## [1] &quot;#&quot; &quot;myRBook_FR&quot; &quot;Vous&quot; ## [4] &quot;trouverez&quot; &quot;ici&quot; &quot;le&quot; ## [7] &quot;code&quot; &quot;source&quot; &quot;du&quot; ## [10] &quot;livre&quot; &quot;*Se&quot; &quot;former&quot; ## [13] &quot;au&quot; &quot;logiciel&quot; &quot;R&quot; ## [16] &quot;:&quot; &quot;initiation&quot; &quot;et&quot; ## [19] &quot;perfectionnement*,&quot; &quot;construit&quot; &quot;avec&quot; ## [22] &quot;bookdown.&quot; 10.2 Exporter ou charger des données pour R Il est parfois utile de pouvoir sauvegarder un objet R pour pouvoir le réutiliser plus tard. C’est le cas par exemple lorsque le temps de calcul pour arriver à un résultat est très long, ou alors lorsque l’on souhaite libérer de l’espace dans la RAM. Pour ce faire il existe la fonction save() qui prend comme argument principal le nom de ou des objets que nous voulons sauvegarder. L’objet sauvé va être stocké dans un fichier. Par convention, il est bon de donner le nom d’extension .RData aux fichiers contenant des objets R, de préférer un seul objet par fichier, et de donner le nom de l’objet comme nom de fichier. myObject &lt;- 5 ls(pattern = &quot;myObject&quot;) ## [1] &quot;myObject&quot; save(myObject, file = &quot;myFiles/myObject.RData&quot;) rm(myObject) ls(pattern = &quot;myObject&quot;) ## character(0) Lors de la session de R suivante ou si nous avons à nouveau besoin de l’objet sauvegardé dans un fichier, nous pouvons le recharger avec la fonction load(). ls(pattern = &quot;myObject&quot;) ## character(0) load(&quot;myFiles/myObject.RData&quot;) ls(pattern = &quot;myObject&quot;) ## [1] &quot;myObject&quot; print(myObject) ## [1] 5 10.3 Exporter des données Le meilleur moyen de communiquer vos résultats ou vos données est de transmettre vos scripts et vos fichiers de données. Parfois ce n’est pas possible ou pas adapté, et il peut être utile d’exporter ses données dans un fichier texte ou CSV. Pour ce faire il existe la fonction générique write() et la fonction write.table() pour les data.frame. Par exemple nous allons créer une data.frame avec les numéros de 1 à 26 et les lettres correspondantes, puis les sauver dans un fichier CSV, puis lire les données contenues dans ce fichier. dfLetters &lt;- data.frame(num = 1:26, letters = letters) write.table(dfLetters, file = &quot;myFiles/dfLetters.csv&quot;, sep = &quot;,&quot;, col.names = TRUE, row.names = FALSE) read.table(file = &quot;myFiles/dfLetters.csv&quot;, header = TRUE, sep = &quot;,&quot;) ## num letters ## 1 1 a ## 2 2 b ## 3 3 c ## 4 4 d ## 5 5 e ## 6 6 f ## 7 7 g ## 8 8 h ## 9 9 i ## 10 10 j ## 11 11 k ## 12 12 l ## 13 13 m ## 14 14 n ## 15 15 o ## 16 16 p ## 17 17 q ## 18 18 r ## 19 19 s ## 20 20 t ## 21 21 u ## 22 22 v ## 23 23 w ## 24 24 x ## 25 25 y ## 26 26 z 10.4 Conclusion Félicitations ! Nous savons désormais comment lire des données contenues dans un fichier texte ou CSV, sauver et charger des données RData, et écrire dans un fichier. Rappelons que l’erreur la plus commune chez les débutants en R est la lecture des fichiers de données et l’organisation des fichiers. C’est pourquoi ce chapitre est à lire et à relire sans modération. "],
["algo.html", " 11 Algorithmique 11.1 Tests logiques avec if 11.2 Tests logiques avec switch 11.3 La boucle for 11.4 La boucle while 11.5 La boucle repeat 11.6 next, break, stop 11.7 Les boucles de la famille apply 11.8 Conclusion", " 11 Algorithmique 11.1 Tests logiques avec if Si nous voulons effectuer une opération différente en fonction d’une condition, nous pouvons mettre en place un test logique du type SI ceci ALORS faire cela SINON faire cela. Avec R cela va se traduire par la fonction if(cond) cons.expr else alt.expr comme indiqué dans l’aide de la fonction. myVar &lt;- 2 if(myVar &lt; 3) print(&quot;myVar &lt; 3&quot;) ## [1] &quot;myVar &lt; 3&quot; if(myVar &lt; 3) print(&quot;myVar &lt; 3&quot;) else print(&quot;myVar &gt; 3&quot;) ## [1] &quot;myVar &lt; 3&quot; Lorsque il y a plusieurs lignes de codes à exécuter en fonction du test logique, ou simplement pour rendre le code plus facile à lire, nous allons utiliser plusieurs lignes avec les acolades {} et en utilisant l’indentation. myVar &lt;- 2 myResult &lt;- 0 if(myVar &lt; 3){ print(&quot;myVar &lt; 3&quot;) myResult &lt;- myVar + 10 } else { print(&quot;myVar &gt; 3&quot;) myResult &lt;- myVar - 10 } ## [1] &quot;myVar &lt; 3&quot; print(myResult) ## [1] 12 Dans cet exemple nous définissons une variable myVar. Si cette variable est inférieure à 3 alors la variable myResult prend comme valeur myVar + 10, et dans le cas contraire myResult prend comme valeur myVar - 10. Nous avions déjà vu l’utilisation du test logique if dans le chapitre sur les fonctions. Nous avions alors testé si la variable entrée comme argument dans notre fonction était bien de type character. myVar &lt;- &quot;qwerty&quot; if(is.character(myVar)){ print(&quot;ok&quot;) } else { print(&quot;error&quot;) } ## [1] &quot;ok&quot; Nous pouvons aussi imbriquer les tests logiques les uns dans les autres. myVar &lt;- TRUE if(is.character(myVar)){ print(&quot;myVar: character&quot;) } else { if(is.numeric(myVar)){ print(&quot;myVar: numeric&quot;) } else { if(is.logical(myVar)){ print(&quot;myVar: logical&quot;) } else { print(&quot;myVar: ...&quot;) } } } ## [1] &quot;myVar: logical&quot; Il est aussi possible de stipuler plusieurs conditions, comme nous l’avons vu lors du chapitre sur les opérateurs de comparaison. myVar &lt;- 2 if(myVar &gt; 1 &amp; myVar &lt; 50){ print(&quot;ok&quot;) } ## [1] &quot;ok&quot; Dans cet exemple myVar est au format numeric donc la première condition (&gt;1), et la seconde condition (&lt;50) sont toutes les deux vérifiables. Par contre si nous affectons une variable de type character à myVar alors R va transformer 0 et 10 en objets de type character et tester si myVar &gt; &quot;1&quot; puis si myVar &lt; &quot;50&quot; en se basant sur un tri par ordre alphabétique. Dans l’exemple suivant &quot;azerty&quot; n’est pas situé par ordre alphabétique entre &quot;1&quot; et &quot;50&quot;, par contre c’est le cas de &quot;2azerty&quot;. myVar &lt;- &quot;azerty&quot; limInit &lt;- 1 limEnd &lt;- 50 if(myVar &gt; limInit &amp; myVar &lt; limEnd){ print(paste0(myVar, &quot; is between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } else { print(paste0(myVar, &quot; not between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } ## [1] &quot;azerty not between 1 and 50.&quot; myVar &lt;- &quot;2azerty&quot; if(myVar &gt; limInit &amp; myVar &lt; limEnd){ print(paste0(myVar, &quot; is between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } else { print(paste0(myVar, &quot; not between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } ## [1] &quot;2azerty is between 1 and 50.&quot; Donc ce que nous voudrions faire est de tester si myVar est bien au format numeric puis uniquement si c’est le cas de tester les conditions suivantes. myVar &lt;- &quot;2azerty&quot; if(is.numeric(myVar)){ if(myVar &gt; limInit &amp; myVar &lt; limEnd){ print(paste0(myVar, &quot; is between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } else { print(paste0(myVar, &quot; not between &quot;, limInit, &quot; and &quot;, limEnd, &quot;.&quot;)) } } else { print(paste0(&quot;Object &quot;, myVar, &quot; is not numeric&quot;)) } ## [1] &quot;Object 2azerty is not numeric&quot; Parfois, nous pouvons avoir besoin de tester une première condition puis une seconde condition uniquement si la première se vérifie dans un même test. Par exemple, pour un site nous voudrions savoir si il y a une seule espèces et tester si son abondance est supérieure à 10. Imaginons un jeu de données avec sous forme de vecteur les abondances. Nous allons tester le nombre d’espèces avec la fonction length(). mySpecies &lt;- c(15, 14, 20, 12) if(length(mySpecies) == 1 &amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } ## Warning message: ## In if (length(mySpecies) == 1 &amp; mySpecies &gt; 10) { : ## the condition has length &gt; 1 and only the first element will be used R renvoie une erreur car il ne peut pas au sein d’un test logique avec if() vérifier la seconde condition. En effet, mySpecies &gt; 10 renvoie TRUE TRUE TRUE TRUE TRUE. Nous pouvons séparer le code en deux conditions : mySpecies &lt;- c(15, 14, 20, 12) if(length(mySpecies) == 1){ if(mySpecies &gt; 10){ print(&quot;ok!&quot;) } } Une alternative plus élégante consiste à spécifier à R de vérifier la seconde condition uniquement si la première est vraie. Pour cela nous pouvons utiliser &amp;&amp; à la place de &amp;. mySpecies &lt;- c(15, 14, 20, 12) if(length(mySpecies) == 1 &amp;&amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } mySpecies &lt;- 15 if(length(mySpecies) == 1 &amp;&amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } ## [1] &quot;ok!&quot; mySpecies &lt;- 5 if(length(mySpecies) == 1 &amp;&amp; mySpecies &gt; 10){ print(&quot;ok!&quot;) } Avec &amp; R va vérifier toutes les conditions, et avec &amp;&amp; R va prendre chaque condition l’une après l’autre et poursuivre uniquement si elle se vérifie. Cela peut paraître anecdotique mais il est bon de connaître la différence entre &amp; et &amp;&amp; car nous les rencontrons souvent dans les codes disponibles sur Internet ou dans les packages. 11.2 Tests logiques avec switch La fonction switch() est une variante de if() qui est utile lorsque nous avons de nombreuses options possibles sur une même expression. L’exemple suivant montre comment transformer un code utilisant if() en switch(). x &lt;- &quot;aa&quot; if(x == &quot;a&quot;){ result &lt;- 1 } if(x == &quot;aa&quot;){ result &lt;- 2 } if(x == &quot;aaa&quot;){ result &lt;- 3 } if(x == &quot;aaaa&quot;){ result &lt;- 4 } print(result) ## [1] 2 x &lt;- &quot;aa&quot; switch(x, a = result &lt;- 1, aa = result &lt;- 2, aaa = result &lt;- 3, aaaa = result &lt;- 4) print(result) ## [1] 2 11.3 La boucle for En programmation, lorsque nous sommes amenés à répéter plusieurs fois la même ligne de code, c’est un signe indiquant qu’il faut utiliser une boucle. Une boucle est une manière d’itérer sur un ensemble d’objets (ou sur les éléments d’un objet), et de répéter une opération. Imaginons une data.frame avec des mesures de terrain à deux dates. bdd &lt;- data.frame(date01 = rnorm(n = 100, mean = 10, sd = 1), date02 = rnorm(n = 100, mean = 10, sd = 1)) print(head(bdd)) ## date01 date02 ## 1 8.823489 9.063619 ## 2 10.050690 10.496109 ## 3 10.277072 9.680109 ## 4 11.281165 9.424554 ## 5 11.218673 10.954975 ## 6 9.529716 10.813109 Nous voudrions quantifier la différence entre la première et la deuxième date, puis mettre un indicateur pour savoir si cette différence est petite ou grande, par exemple avec un seuil arbitraire de 3. Donc pour chaque ligne nous pourrions faire : bdd$dif &lt;- NA bdd$isDifBig &lt;- NA bdd$dif[1] &lt;- sqrt((bdd$date01[1] - bdd$date02[1])^2) bdd$dif[2] &lt;- sqrt((bdd$date01[2] - bdd$date02[2])^2) bdd$dif[3] &lt;- sqrt((bdd$date01[3] - bdd$date02[3])^2) # ... bdd$dif[100] &lt;- sqrt((bdd$date01[100] - bdd$date02[100])^2) if(bdd$dif[1] &gt; 3){ bdd$isDifBig[1] &lt;- &quot;big&quot; }else{ bdd$isDifBig[1] &lt;- &quot;small&quot; } if(bdd$dif[2] &gt; 3){ bdd$isDifBig[2] &lt;- &quot;big&quot; }else{ bdd$isDifBig[2] &lt;- &quot;small&quot; } if(bdd$dif[3] &gt; 3){ bdd$isDifBig[3] &lt;- &quot;big&quot; }else{ bdd$isDifBig[3] &lt;- &quot;small&quot; } # ... if(bdd$dif[100] &gt; 3){ bdd$isDifBig[100] &lt;- &quot;big&quot; }else{ bdd$isDifBig[100] &lt;- &quot;small&quot; } Cette façon de faire serait extrêmement fastidieuse à réaliser, et même presque impossible à réaliser si la table contenait 1000 ou 100000 lignes. Il pourrait sembler logique de vouloir itérer sur les lignes de notre data.frame pour obtenir les nouvelles colonnes. Nous allons le réaliser même si ce n’est pas la solution que nous allons retenir par la suite. Nous allons utiliser une boucle for(). La boucle for() va itérer sur les éléments d’un objet que nous allons donner en argument. Par exemple voici une boucle qui pour tous les chiffres de 3 à 9 va calculer leur valeur au carré. La valeur courante du chiffre est symbolisé par un objet qui peut prendre le nom que nous souhaitons (ici cela sera i). for(i in c(3, 4, 5, 6, 7, 8, 9)){ print(i^2) } ## [1] 9 ## [1] 16 ## [1] 25 ## [1] 36 ## [1] 49 ## [1] 64 ## [1] 81 Que nous pouvons améliorer en utilisant la fonction :. for(i in 3:9){ print(i^2) } Le choix du nom i est ici arbitraire, nous aurions pu choisir myVarFor de la même façon : for(myVarFor in 3:9){ print(myVarFor^2) } La boucle for() peut itérer sur tous les types d’éléments. nChar &lt;- c(&quot;a&quot;, &quot;z&quot;, &quot;e&quot;, &quot;r&quot;, &quot;t&quot;, &quot;y&quot;) for(i in nChar){ print(i) } ## [1] &quot;a&quot; ## [1] &quot;z&quot; ## [1] &quot;e&quot; ## [1] &quot;r&quot; ## [1] &quot;t&quot; ## [1] &quot;y&quot; Revenons à notre cas. Nous allons itérer sur le nombre de ligne de notre data.frame bdd. Avant cela nous allons créer les colonnes dif et isDifBig avec les valeurs NA. Ensuite nous allons utiliser la fonction nrow() pour connaître le nombre de lignes. bdd$dif &lt;- NA bdd$isDifBig &lt;- NA for(i in 1:nrow(bdd)){ bdd$dif[i] &lt;- sqrt((bdd$date01[i] - bdd$date02[i])^2) if(bdd$dif[i] &gt; 3){ bdd$isDifBig[i] &lt;- &quot;big&quot; }else{ bdd$isDifBig[i] &lt;- &quot;small&quot; } } print(head(bdd, n = 20)) ## date01 date02 dif isDifBig ## 1 8.823489 9.063619 0.2401304 small ## 2 10.050690 10.496109 0.4454193 small ## 3 10.277072 9.680109 0.5969623 small ## 4 11.281165 9.424554 1.8566115 small ## 5 11.218673 10.954975 0.2636977 small ## 6 9.529716 10.813109 1.2833925 small ## 7 9.296546 11.017394 1.7208480 small ## 8 9.728551 8.201687 1.5268645 small ## 9 10.140014 9.891183 0.2488310 small ## 10 9.362229 11.611363 2.2491345 small ## 11 11.519061 8.591731 2.9273305 small ## 12 9.147642 10.078499 0.9308562 small ## 13 11.907973 7.935171 3.9728022 big ## 14 9.024207 10.500196 1.4759891 small ## 15 9.737544 9.099618 0.6379258 small ## 16 9.158641 9.954105 0.7954641 small ## 17 9.744693 10.349591 0.6048979 small ## 18 9.622180 9.969114 0.3469343 small ## 19 9.048698 10.972096 1.9233975 small ## 20 11.858536 11.372542 0.4859941 small En pratique ce n’est pas la meilleure façon de réaliser cet exercice car il s’agit ici de simples calculs sur des vecteurs contenus dans une data.frame. R est particulièrement puissant pour effectuer des opérations sur des vecteurs. Lorsque cela est possible il faut donc toujours privilégier les opérations sur les vecteurs. Ici notre code devient : bdd$dif &lt;- sqrt((bdd$date01 - bdd$date02)^2) bdd$isDifBig &lt;- &quot;small&quot; bdd$isDifBig[bdd$dif &gt; 3] &lt;- &quot;big&quot; print(head(bdd, n = 20)) ## date01 date02 dif isDifBig ## 1 8.823489 9.063619 0.2401304 small ## 2 10.050690 10.496109 0.4454193 small ## 3 10.277072 9.680109 0.5969623 small ## 4 11.281165 9.424554 1.8566115 small ## 5 11.218673 10.954975 0.2636977 small ## 6 9.529716 10.813109 1.2833925 small ## 7 9.296546 11.017394 1.7208480 small ## 8 9.728551 8.201687 1.5268645 small ## 9 10.140014 9.891183 0.2488310 small ## 10 9.362229 11.611363 2.2491345 small ## 11 11.519061 8.591731 2.9273305 small ## 12 9.147642 10.078499 0.9308562 small ## 13 11.907973 7.935171 3.9728022 big ## 14 9.024207 10.500196 1.4759891 small ## 15 9.737544 9.099618 0.6379258 small ## 16 9.158641 9.954105 0.7954641 small ## 17 9.744693 10.349591 0.6048979 small ## 18 9.622180 9.969114 0.3469343 small ## 19 9.048698 10.972096 1.9233975 small ## 20 11.858536 11.372542 0.4859941 small La plupart des exemples que l’on peut trouver sur Internet à propos de la boucle for() peuvent être remplacés par des opérations sur les vecteurs. Voici quelques exemples adaptés de plusieurs sources : # tester si des nombres sont pairs # [1] FOR x &lt;- sample(1:100, size = 20) count &lt;- 0 for (val in x) { if(val %% 2 == 0){ count &lt;- count + 1 } } print(count) ## [1] 10 # [2] VECTOR sum(x %% 2 == 0) ## [1] 10 # calculer des carrés # [1] FOR x &lt;- rep(0, 20) for (j in 1:20){ x[j] &lt;- j^2 } print(x) ## [1] 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 ## [18] 324 361 400 # [2] VECTOR (1:20)^2 ## [1] 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 ## [18] 324 361 400 # répéter un lancer de dés et faire la moyenne # [1] FOR ntrials = 1000 trials = rep(0, ntrials) for (j in 1:ntrials){ trials[j] = sample(1:6, size = 1) } mean(trials) ## [1] 3.469 # [2] VECTOR mean(sample(1:6, ntrials, replace = TRUE)) ## [1] 3.432 C’est un bon exercice de parcourir les nombreux exemples disponibles sur Internet sur la boucle for() et de tenter de les transformer en opérations vectorielles. Cela nous permet d’acquérir les bons réflexes de programmation avec R. La boucle for() reste très utile pour par exemple lire plusieurs fichiers et traiter l’information qu’ils contiennent de la même façon, faire des graphiques, ou encore lorsque les opérations vectorielles deveinnent fastidieuses. Imaginons une matrice de 10 colonnes et 100 lignes. Nous voulons la somme de chaque ligne (nous verrons plus loin comment faire avec la fonction apply()). myMat &lt;- matrix(sample(1:100, size = 1000, replace = TRUE), ncol = 10) # VECTOR sumRow &lt;- myMat[, 1] + myMat[, 2] + myMat[, 3] + myMat[, 4] + myMat[, 5] + myMat[, 6] + myMat[, 7] + myMat[, 8] + myMat[, 9] + myMat[, 10] print(sumRow) ## [1] 563 556 439 666 665 565 523 554 536 365 496 383 378 471 447 502 520 ## [18] 354 333 499 686 622 352 630 525 371 550 681 508 383 350 496 430 631 ## [35] 393 412 549 619 550 465 335 539 595 375 402 484 424 409 590 443 440 ## [52] 453 440 496 534 499 496 474 477 685 546 481 635 379 530 407 471 520 ## [69] 577 734 583 444 534 624 553 280 519 621 477 508 528 570 735 531 371 ## [86] 595 566 641 525 238 761 579 538 428 499 469 584 642 474 571 # FOR sumRow &lt;- rep(NA, times = nrow(myMat)) for(j in 1:nrow(myMat)){ sumRow[j] &lt;- sum(myMat[j, ]) } print(sumRow) ## [1] 563 556 439 666 665 565 523 554 536 365 496 383 378 471 447 502 520 ## [18] 354 333 499 686 622 352 630 525 371 550 681 508 383 350 496 430 631 ## [35] 393 412 549 619 550 465 335 539 595 375 402 484 424 409 590 443 440 ## [52] 453 440 496 534 499 496 474 477 685 546 481 635 379 530 407 471 520 ## [69] 577 734 583 444 534 624 553 280 519 621 477 508 528 570 735 531 371 ## [86] 595 566 641 525 238 761 579 538 428 499 469 584 642 474 571 En conclusion, il est recommandé de ne pas utiliser la boucle for() avec R chaque fois que cela est possible, et nous verrons dans ce chapitre des alternatives commes les boucles de la famille apply(). 11.4 La boucle while La boucle while(), contrairement à la boucle for(), signifie TANT QUE. Tant qu’une condition n’est pas remplie, la boucle va continuer à s’exécuter. Attention car en cas d’erreur, nous pouvons facilement programmer des boucles qui ne terminent jamais ! Cette boucle est moins courante que la boucle for(). prenons un exemple : i &lt;- 0 while(i &lt; 10){ print(i) i &lt;- i + 1 } ## [1] 0 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 Dans cet exemple, la variable i a comme valeur 0. TANT QUE i &lt; 10, nous allons afficher i. Pour que cette boucle se termine, il ne faut pas oublier de modifier la valeur de i, c’est ce qui est fait avec la ligne i &lt;- i + 1. Lorsque la condition i &lt; 10 ne se vérifie plus, la boucle s’arrête. La boucle while() est très utile pour créer des scripts qui vont effectuer des calculs sur des variables dont la valeur évoluent dans le temps. Par exemple imaginons un nombre entre 0 et 10000 et un générateur aléatoire qui va essayer de déterminer la valeur de ce nombre. Si nous souhaitons limiter les tentatives de R à 2 secondes, nous pouvons écrire le script suivant (qui devrait marcher à tous les coups sur un ordinateur de bureau classique pouvant facilement effectuer 35000 essais en 2 secondes) : myNumber &lt;- sample(x = 10000, size = 1) myGuess &lt;- sample(x = 10000, size = 1) startTime &lt;- Sys.time() numberGuess &lt;- 0 while(Sys.time() - startTime &lt; 2){ if(myGuess == myNumber){ numberGuess &lt;- numberGuess + 1 print(&quot;Number found !&quot;) print(paste0(&quot;And I have plenty of time left: &quot;, round(2 - as.numeric(Sys.time() - startTime), digits = 2), &quot; sec&quot;)) break }else{ myGuess &lt;- sample(x = 10000, size = 1) numberGuess &lt;- numberGuess + 1 } } ## [1] &quot;Number found !&quot; ## [1] &quot;And I have plenty of time left: 1.44 sec&quot; Dans ce script nous générons un nombre aléatoire à deviner avec la fonction sample(), et chaque essai avec la même fonction sample(). Ensuite nous utilisons la fonction Sys.time() (avec un S majuscule à Sys), pour connaître l’heure de début de la boucle. Tant que la différence entre chaque itération de la boucle et l’heure de démarrage est inférieur à 2 secondes, la boucle while() va vérifier si le bon nombre a été deviner dans le test logique avec if() puis si c’est le cas nous informer que le nombre a été trouvé, nous dire le temps restant avant les deux secondes, puis terminer la boucle avec le mot clef break sur lequel nous reviendrons. En bref, break permet de sortir d’une boucle. Si le nombre n’a pas été deviné, la boucle fait un autre essai avec la fonction sample(). Plus concrètement nous pourrions imaginer des algorithmes pour explorer un espace de solutions face à un problème avec un temps limité pour y parvenir. La boucle while() peut aussi être pratique pour qu’un script ne s’exécute que lorsque un fichier issu d’un autre programme devient disponible… En pratique la boucle while() reste peu utilisée avec R. 11.5 La boucle repeat La boucle repeat() permet de répéter une opération sans condition à vérifier. Pour sortir de cette boucle il faut donc obligatoirement utiliser le mot clef break. i &lt;- 1 repeat{ print(i^2) i &lt;- i + 1 if(i == 5){ break } } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 16 Si nous reprenons l’exemple précédent, nous pouvons utiliser une boucle repeat() pour le répéter 5 fois. numTry &lt;- 0 repeat{ myNumber &lt;- sample(x = 10000, size = 1) myGuess &lt;- sample(x = 10000, size = 1) startTime &lt;- Sys.time() numberGuess &lt;- 0 while(Sys.time() - startTime &lt; 2){ if(myGuess == myNumber){ numberGuess &lt;- numberGuess + 1 print(round(as.numeric(Sys.time() - startTime), digits = 3)) break }else{ myGuess &lt;- sample(x = 10000, size = 1) numberGuess &lt;- numberGuess + 1 } } numTry &lt;- numTry + 1 if(numTry == 5){break} } ## [1] 0.391 ## [1] 0.031 ## [1] 0.034 ## [1] 0.037 ## [1] 0.069 Comme la boucle while(), la boucle repeat() reste peu utlisée avec R. 11.6 next, break, stop XXX 11.7 Les boucles de la famille apply 11.7.1 apply XXX 11.7.2 sapply XXX 11.7.3 lapply XXX 11.7.4 tapply XXX 11.7.5 mapply XXX 11.7.6 rapply XXX 11.7.7 vapply 11.8 Conclusion Félicitations, nous sommes arrivés au bout de ce chapitre sur l’algorithmique. Retenons ce message clef : dès qu’une opération doit être réalisée plus de deux fois dans un script en répétant du code qui a été déjà écrit, c’est un signe qui doit nous conduire à l’utilisation d’une boucle. Pour autant, chaque fois que cela est possible, il est recommandé de ne pas utiliser les boucles traditionnelles for(), while(), et repeat(), mais de préférer les opération sur les vecteurs ou encore les boucles de la famille apply. Cela peut être assez difficile à intégrer au début mais nous verrons que nos scripts seront plus faciles à maintenir et à lire, et beaucoup plus performants si nous suivons ces habitudes. "],
["project.html", " 12 Gestion d’un projet avec R 12.1 Gestion des fichiers et du répertoire de travail 12.2 Gestion des versions de script 12.3 Gestion de la documentation", " 12 Gestion d’un projet avec R 12.1 Gestion des fichiers et du répertoire de travail 12.2 Gestion des versions de script 12.3 Gestion de la documentation "],
["concluP1.html", " 13 Conclusion", " 13 Conclusion "],
["graph1.html", " 14 Graphiques simples 14.1 plot 14.2 hist 14.3 barplot 14.4 boxplot 14.5 image et contour", " 14 Graphiques simples 14.1 plot 14.2 hist 14.3 barplot 14.4 boxplot 14.5 image et contour "],
["graph2.html", " 15 La gestion des couleurs 15.1 colors() 15.2 RGB 15.3 Paletas", " 15 La gestion des couleurs 15.1 colors() 15.2 RGB 15.3 Paletas "],
["graph3.html", " 16 Graphiques composés 16.1 mfrow 16.2 layout", " 16 Graphiques composés 16.1 mfrow 16.2 layout "],
["graph4.html", " 17 Manipuler les graphiques 17.1 Inkscape 17.2 The Gimp", " 17 Manipuler les graphiques 17.1 Inkscape 17.2 The Gimp "],
["concluP2.html", " 18 Conclusion", " 18 Conclusion "],
["p3script.html", " 19 Les scripts", " 19 Les scripts "],
["p3data.html", " 20 Les données", " 20 Les données "],
["p3example.html", " 21 Quelques exemples", " 21 Quelques exemples "],
["p3conclu.html", " 22 Conclusion", " 22 Conclusion "],
["studyCase001.html", " 23 Analyser des données de datalogger de température", " 23 Analyser des données de datalogger de température Dans les études de biologie, d’écologie ou d’agronomie, nous utilisons fréquemment des données de température provenant de dataloggers. Dans cette étude de cas, nous verrons comment analyser ces données en utilisant les données de température de l’altiplano bolivien près de la ville de El Alto. La première étape consiste à transformer les données du datalogger en un format facile à lire pour R. Nous utiliserons un fichier CSV et la fonction read.table(). Le fichier peut être téléchargé à partir du site Web du livre sur GitHub (https://github.com/frareb/myRBook_FR/blob/master/myFiles/E05C13.csv ; cliquez avec le bouton droit sur le lien et sélectionnez “Enregistrer la cible du lien sous…”). bdd &lt;- read.table(&quot;myFiles/E05C13.csv&quot;, skip = 1, header = TRUE, sep = &quot;,&quot;, dec = &quot;.&quot;, stringsAsFactors = FALSE) colnames(bdd) &lt;- c(&quot;id&quot;, &quot;date&quot;, &quot;temp&quot;) head(bdd) ## id date temp ## 1 1 11/12/15 23:00:00 4.973 ## 2 2 11/12/15 23:30:00 4.766 ## 3 3 11/13/15 00:00:00 4.844 ## 4 4 11/13/15 00:30:00 4.844 ## 5 5 11/13/15 01:00:00 5.076 ## 6 6 11/13/15 01:30:00 5.282 tail(bdd) ## id date temp ## 32781 32781 09/25/17 21:00:00 7.091 ## 32782 32782 09/25/17 21:30:00 6.914 ## 32783 32783 09/25/17 22:00:00 6.813 ## 32784 32784 09/25/17 22:30:00 6.611 ## 32785 32785 09/25/17 23:00:00 6.331 ## 32786 32786 09/25/17 23:30:00 5.385 str(bdd) ## &#39;data.frame&#39;: 32786 obs. of 3 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ date: chr &quot;11/12/15 23:00:00&quot; &quot;11/12/15 23:30:00&quot; &quot;11/13/15 00:00:00&quot; &quot;11/13/15 00:30:00&quot; ... ## $ temp: num 4.97 4.77 4.84 4.84 5.08 ... Nous pouvons voir que la date est au format character et qu’elle contient la date avec le mois, le jour et l’année séparés par /, puis vient un espace et l’heure avec des heures de 0 à 24, minutes et secondes, séparés par : (exemple: 11/12/15 23:00:00 pour le 12 novembre 2015 à 11 heures du soir). Nous allons séparer les informations en plusieurs objets. Séparons d’abord la date de l’heure. Pour cela, nous utiliserons la fonction strsplit() en utilisant l’espace entre la date et l’heure comme séparateur. strsplit(&quot;11/12/15 23:00:00&quot;, split = &quot; &quot;) ## [[1]] ## [1] &quot;11/12/15&quot; &quot;23:00:00&quot; Comme l’indiquent les doubles crochets, la fonction strsplit() renvoie un objet au format list. Nous voulons le vecteur qui correspond au premier élément de la liste, donc nous allons ajouter [[1]]. strsplit(&quot;11/12/15 23:00:00&quot;, split = &quot; &quot;)[[1]] ## [1] &quot;11/12/15&quot; &quot;23:00:00&quot; Le premier élément du vector est la date. Pour avoir toutes les dates, nous allons faire une boucle avec la fonction sapply(). bddDay &lt;- sapply(strsplit(bdd[, 2], split = &quot; &quot;), &quot;[[&quot;, 1) head(bddDay) ## [1] &quot;11/12/15&quot; &quot;11/12/15&quot; &quot;11/13/15&quot; &quot;11/13/15&quot; &quot;11/13/15&quot; &quot;11/13/15&quot; Ensuite, nous aurons besoin des dates dans le format factor (fonction aggregate() pour obtenir les informations par jour). Nous devons donc transformer l’objet dans le format factor avec la fonction as.factor(). bddDay &lt;- as.factor(sapply(strsplit(bdd[, 2], split = &quot; &quot;), &quot;[[&quot;, 1)) head(bddDay) ## [1] 11/12/15 11/12/15 11/13/15 11/13/15 11/13/15 11/13/15 ## 684 Levels: 01/01/16 01/01/17 01/02/16 01/02/17 01/03/16 ... 12/31/16 En effectuant la transformation vers le format factor, les différents facteurs de notre objet sont classés par ordre alphabétique comme si les dates correspondaient à du simple texte. C’est problématique car l’ordre des facteurs doit correspondre à l’ordre des dates. Pour cela, nous allons créer un vector avec toutes les dates uniques avec la fonction unique(), puis trier les dates avec la fonction sort.list() en utilisant les dates avec la fonction as.POSIXct(). Le résultat sera l’objet lev. Nous allons utiliser le vecteur lev pour spécifier comment les facteurs de nos dates devraient être classées. Le travail avec les dates est souvent fastidieux, c’est pourquoi il existe des packages spécialisés dans leur gestion. Ici nous avons préféré utiliser les fonctions de base de R dans un objectif pédagogique. bddDay &lt;- as.factor(sapply(strsplit(bdd[, 2], split = &quot; &quot;), &quot;[[&quot;, 1)) udate &lt;- unique(bddDay) lev &lt;- udate[sort.list(as.POSIXct(strptime(udate, &quot;%m/%d/%y&quot;)))] bddDay &lt;- factor(bddDay, levels = lev) head(bddDay) ## [1] 11/12/15 11/12/15 11/13/15 11/13/15 11/13/15 11/13/15 ## 684 Levels: 11/12/15 11/13/15 11/14/15 11/15/15 11/16/15 ... 09/25/17 Maintenant, nous pouvons ajouter les dates comme nouvelle colonne de l’objet bdd et faire la même chose pour les heures (il n’est pas nécessaire de réorganiser les niveaux de l’haure car l’ordre par défaut correspond à ce que nous voulons). bdd$bddDay &lt;- bddDay bdd$bddHour &lt;- as.factor(sapply(strsplit(bdd[, 2], split = &quot; &quot;), &quot;[[&quot;, 2)) head(bdd) ## id date temp bddDay bddHour ## 1 1 11/12/15 23:00:00 4.973 11/12/15 23:00:00 ## 2 2 11/12/15 23:30:00 4.766 11/12/15 23:30:00 ## 3 3 11/13/15 00:00:00 4.844 11/13/15 00:00:00 ## 4 4 11/13/15 00:30:00 4.844 11/13/15 00:30:00 ## 5 5 11/13/15 01:00:00 5.076 11/13/15 01:00:00 ## 6 6 11/13/15 01:30:00 5.282 11/13/15 01:30:00 Nous pouvons visualiser les données avec la fonction plot(), en spécifiant le format des dates avec la fonction as.Date() plot(x = as.Date(bdd$bddDay, format = &quot;%m/%d/%y&quot;), y = bdd$temp, type = &#39;l&#39;, ylim = c(-15, 40), xlab = &quot;Temps&quot;, ylab = &quot;Température (°C)&quot;) Nous pouvons simplifier les informations en ne calculant que les températures minimales, moyennes et maximales avec la fonction aggregate(). tempDayMean &lt;- aggregate(x = bdd[, 3], by = list(bdd[, 4]), FUN = mean) tempDayMin &lt;- aggregate(x = bdd[, 3], by = list(bdd[, 4]), FUN = min) tempDayMax &lt;- aggregate(x = bdd[, 3], by = list(bdd[, 4]), FUN = max) plot(x = as.Date(tempDayMean[, 1], format = &quot;%m/%d/%y&quot;), y = tempDayMean[, 2], type = &#39;l&#39;, ylim = c(-15, 40), xlab = &quot;Temps&quot;, ylab = &quot;Température (°C)&quot;) points(x = as.Date(tempDayMin[, 1], format = &quot;%m/%d/%y&quot;), y = tempDayMin[, 2], type = &#39;l&#39;, col = 4) points(x = as.Date(tempDayMax[, 1], format = &quot;%m/%d/%y&quot;), y = tempDayMax[, 2], type = &#39;l&#39;, col = 2) legend(&quot;topright&quot;, legend = c(&quot;min&quot;, &quot;max&quot;, &quot;mean&quot;), lty = 1, lwd = 2, col = c(4, 2, 1)) Nous pouvons également calculer la différence entre la température maximale et la température minimale (variation de la température diurne). tempDayTR &lt;- tempDayMax[, 2] - tempDayMin[, 2] plot(x = as.Date(tempDayMean[, 1], format = &quot;%m/%d/%y&quot;), y = tempDayTR, type = &#39;l&#39;, ylim = c(5, 45), xlab = &quot;Temps&quot;, ylab = &quot;Variation de température diurne (°C)&quot;) Une autre possibilité est de regrouper les données pour avoir la température moyenne des heures de la journée avec la fonction aggregate(). tempHourMean &lt;- aggregate(x = bdd[, 3], by = list(bdd[, 5]), FUN = mean) tempHourMin &lt;- aggregate(x = bdd[, 3], by = list(bdd[, 5]), FUN = min) tempHourMax &lt;- aggregate(x = bdd[, 3], by = list(bdd[, 5]), FUN = max) hours &lt;- seq(from = 0, to = 23.5, by = 0.5) plot(x = hours, y = tempHourMean[, 2], type = &#39;l&#39;, ylim = c(-15, 40), xlab = &quot;&quot;, ylab = &quot;Température (°C)&quot;, lwd = 2, xaxt = &quot;n&quot;, panel.first = { abline(v = hours, col = &quot;gray&quot;, lty = 2) abline(h = 0, lty = 2) }) axis(side = 1, at = hours, labels = tempHourMean[, 1], las = 2) points(x = hours, y = tempHourMin[, 2], type = &#39;l&#39;, col = 4, lwd = 2) points(x = hours, y = tempHourMax[, 2], type = &#39;l&#39;, col = 2, lwd = 2) Nous pouvons également calculer les températures des heures de la journée pour chaque mois. meses &lt;- c(&quot;Janvier&quot;, &quot;Février&quot;, &quot;Mars&quot;, &quot;Avril&quot;, &quot;Mai&quot;, &quot;Juin&quot;, &quot;Juillet&quot;, &quot;Août&quot;, &quot;Septembre&quot;, &quot;Octobre&quot;, &quot;Novembre&quot;, &quot;Décembre&quot;) hours &lt;- seq(from = 0, to = 23.5, by = 0.5) bddMonth &lt;- sapply(strsplit(as.character(bdd$bddDay), split = &quot;/&quot;), &quot;[[&quot;, 1) tempDayEachMonth &lt;- lapply(sort(unique(bddMonth)), function(myMonth){ bddX &lt;- bdd[bddMonth == myMonth, ] tempHourMean &lt;- aggregate(x = bddX[, 3], by = list(bddX[, 5]), FUN = mean) tempHourMin &lt;- aggregate(x = bddX[, 3], by = list(bddX[, 5]), FUN = min) tempHourMax &lt;- aggregate(x = bddX[, 3], by = list(bddX[, 5]), FUN = max) return(data.frame(tempHourMean, tempHourMin, tempHourMax)) }) for (i in seq_along(tempDayEachMonth)){ plot(x = hours, y = tempDayEachMonth[[i]][, 2], type = &#39;l&#39;, ylim = c(-15, 40), xlab = &quot;&quot;, ylab = &quot;Température (°C)&quot;, lwd = 2, main = meses[i], xaxt = &quot;n&quot;, panel.first = { abline(v = hours, col = &quot;gray&quot;, lty = 2) abline(h = 0, lty = 2) }) axis(side = 1, at = hours, labels = tempHourMean[, 1], las = 2) points(x = hours, y = tempDayEachMonth[[i]][, 4], type = &#39;l&#39;, col = 4, lwd = 2) points(x = hours, y = tempDayEachMonth[[i]][, 6], type = &#39;l&#39;, col = 2, lwd = 2) } Ou les regrouper dans un même graphique, ainsi que la variation diurne des températures pour chaque mois. plot(x = hours, y = tempDayEachMonth[[1]][, 2], type = &#39;n&#39;, ylim = c(-10, 35), xlab = &quot;&quot;, ylab = &quot;Température moyenne (°C)&quot;, xaxt = &quot;n&quot;, panel.first = { abline(v = hours, col = &quot;gray&quot;, lty = 2) abline(h = 0, lty = 2) }) axis(side = 1, at = hours, labels = tempHourMean[, 1], las = 2) myColors &lt;- c(&quot;#A6CEE3&quot;, &quot;#1F78B4&quot;, &quot;#B2DF8A&quot;, &quot;#33A02C&quot;, &quot;#FB9A99&quot;, &quot;#E31A1C&quot;, &quot;#FDBF6F&quot;, &quot;#FF7F00&quot;, &quot;#CAB2D6&quot;, &quot;#6A3D9A&quot;, &quot;#FFFF99&quot;, &quot;#B15928&quot;) for (i in seq_along(tempDayEachMonth)){ points(x = hours, y = tempDayEachMonth[[i]][, 2], type = &#39;l&#39;, col = myColors[i], lwd = 2) } legend(&quot;topright&quot;, ncol = 4, legend = meses, col = myColors, lty = 1, lwd = 2, cex = 0.8) plot(x = hours, y = tempDayEachMonth[[1]][, 2], type = &#39;n&#39;, ylim = c(0, 30), xlab = &quot;&quot;, ylab = &quot;Variation de température diurne (°C)&quot;, xaxt = &quot;n&quot;, panel.first = { abline(v = hours, col = &quot;gray&quot;, lty = 2) abline(h = 0, lty = 2) }) axis(side = 1, at = hours, labels = tempHourMean[, 1], las = 2) myColors &lt;- c(&quot;#A6CEE3&quot;, &quot;#1F78B4&quot;, &quot;#B2DF8A&quot;, &quot;#33A02C&quot;, &quot;#FB9A99&quot;, &quot;#E31A1C&quot;, &quot;#FDBF6F&quot;, &quot;#FF7F00&quot;, &quot;#CAB2D6&quot;, &quot;#6A3D9A&quot;, &quot;#FFFF99&quot;, &quot;#B15928&quot;) for (i in seq_along(tempDayEachMonth)){ points(x = hours, y = tempDayEachMonth[[i]][, 6] - tempDayEachMonth[[i]][, 4], type = &#39;l&#39;, col = myColors[i], lwd = 2) } legend(&quot;topright&quot;, ncol = 4, legend = meses, col = myColors, lty = 1, lwd = 2, cex = 0.8) "],
["studyCase002.html", " 24 Obtenir le numéro WOS d’un article scientifique à partir de son numéro DOI", " 24 Obtenir le numéro WOS d’un article scientifique à partir de son numéro DOI Il peut être intéressant d’obtenir le numéro WOS d’un article scientifique. Ce numéro est cependant fastidieux à obtenir, d’autant plus si nous souhaitons le récupérer pour une liste d’articles ! Par chance The Kitchin Research Group dans leur blog de juin 2015 (http://kitchingroup.cheme.cmu.edu/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI/) propose une méthode pour récupérer le numéro WOS à partir du numéro DOI. C’est cette méthode que nous allons utiliser avec R et le package httr. En bref, cette méthode consite à interroger le site web du WOS à partir du numéro DOI. Le site web du WOS va répondre en spécifiant qu’il faut se connecter pour accéder à l’article. Il y a pour cela une redirection vers une page web dont l’URL contient le numéro WOS. Il suffit alors d’extraire le numéro WOS de l’URL de la page web. Si nous utilisons un proxy pour accéder au site web du WOS, il faut donc le désactiver pour que la méthode fonctionne. Tout d’abord si cela n’est pas déjà fait il faut installer le package httr avec install.packages(&quot;httr&quot;), puis le charger avec library(&quot;httr&quot;). Une autre solution consiste à utiliser la fonction suivante qui va vérifier si le package est installé puis le charger (il existe de nombreuses déclinaisons de cette fonction sur internet, il s’agit ici d’un mélange de multiples sources). pkgCheck &lt;- function(packages){ for(x in packages){ try(if (!require(x, character.only = TRUE)){ install.packages(x, dependencies = TRUE) if(!require(x, character.only = TRUE)) { stop() } }) } } pkgCheck(&quot;httr&quot;) La liste des numéros DOI est la suivante (contenu dans un vector) : myDOIs &lt;- c(&quot;10.1111/2041-210X.12935&quot;, &quot;10.1007/s13355-017-0480-5&quot;) print(myDOIs) ## [1] &quot;10.1111/2041-210X.12935&quot; &quot;10.1007/s13355-017-0480-5&quot; Pour chaque DOI, nous allons interroger le site web du WOS, récupérer l’URL de redirection, puis récupérer le numéro WOS. Nous allons donc faire une boucle sur notre vector contenant les DOI. Nous utilisons la fonction seq_along() qui va prendre comme valeurs les éléments d’une séquence de 1 à la taille de l’objet myDOIs, soit : i = 1, puis i = 2. for(i in seq_along(myDOIs)){ # ... } Dans la boucle, le DOI que nous allons traiter est donc myDOIs[i] que nous allons appeler myDOI. La page d’interrogation du WOS correspond à la concaténation de l’URL du WOS avec le numéro WOS (l’URL est présentée sur plusieurs lignes pour respecter la largeur de page de ce livre). for(i in seq_along(myDOIs)){ myDOI &lt;- myDOIs[i] myWebPage &lt;- paste0( &quot;http://ws.isiknowledge.com/&quot;, &quot;cps/openurl/service?url_ver=Z39.88-2004&quot;, &quot;&amp;rft_id=info:doi/&quot;, myDOI) } Maintenant nous allons utiliser la fonction GET() du package httr pour récupérer l’URL. for(i in seq_along(myDOIs)){ myDOI &lt;- myDOIs[i] myWebPage &lt;- paste0( &quot;http://ws.isiknowledge.com/&quot;, &quot;cps/openurl/service?url_ver=Z39.88-2004&quot;, &quot;&amp;rft_id=info:doi/&quot;, myDOI) r &lt;- GET(myWebPage) urlWOS &lt;- r[[1]] } Il se peut que pour un article, il n’y ait pas de numéro WOS correspondant. Pour que notre script ne soit pas arrêté en cas d’erreur il faut donc gérer cette exception. Nous allons créer un objet tryExtract qui va prendre comme valeur une chaîne de caractères vide &quot;&quot;. Ensuite nous allons essayer avec la fonction try() d’extraire le numéro WOS avec la fonction substr(). Le numéro WOS se situe depuis le caractère numéro 117 jusqu’au caractère numéro 131 de l’URL. for(i in seq_along(myDOIs)){ myDOI &lt;- myDOIs[i] myWebPage &lt;- paste0( &quot;http://ws.isiknowledge.com/&quot;, &quot;cps/openurl/service?url_ver=Z39.88-2004&quot;, &quot;&amp;rft_id=info:doi/&quot;, myDOI) r &lt;- GET(myWebPage) urlWOS &lt;- r[[1]] tryExtract &lt;- &quot;&quot; try(tryExtract &lt;- substr(x = urlWOS, start = 117, stop = 131), silent = TRUE) } Nous pouvons ensuite vérifier que l’extraction correspond bien à un numéro en utilisant une expression régulière. Ici nous allons simplement vérifier que l’extraction ne contient que des chiffres. Dans le cas contraire tryExtract reprendra sa valeur initiale &quot;&quot;. for(i in seq_along(myDOIs)){ myDOI &lt;- myDOIs[i] myWebPage &lt;- paste0( &quot;http://ws.isiknowledge.com/&quot;, &quot;cps/openurl/service?url_ver=Z39.88-2004&quot;, &quot;&amp;rft_id=info:doi/&quot;, myDOI) r &lt;- GET(myWebPage) urlWOS &lt;- r[[1]] tryExtract &lt;- &quot;&quot; try(tryExtract &lt;- substr(x = urlWOS, start = 117, stop = 131), silent = TRUE) if(!grepl(pattern = &#39;^[0-9]*$&#39;, x = tryExtract)){tryExtract &lt;- &quot;&quot;} } Le résultat est ensuite stocké dans un vector créé au préalable et appelé vecWOS. vecWOS &lt;- vector() for(i in seq_along(myDOIs)){ myDOI &lt;- myDOIs[i] myWebPage &lt;- paste0( &quot;http://ws.isiknowledge.com/&quot;, &quot;cps/openurl/service?url_ver=Z39.88-2004&quot;, &quot;&amp;rft_id=info:doi/&quot;, myDOI) r &lt;- GET(myWebPage) urlWOS &lt;- r[[1]] tryExtract &lt;- &quot;&quot; try(tryExtract &lt;- substr(x = urlWOS, start = 117, stop = 131), silent = TRUE) if(!grepl(pattern = &#39;^[0-9]*$&#39;, x = tryExtract)){tryExtract &lt;- &quot;&quot;} vecWOS &lt;- append(vecWOS, tryExtract) } Nous pouvons alors créer un objet de type data.frame qui va contenir les numéros DOI et les numéros WOS, et éventuellement l’exporter dans un fichier CSV. dfDOIWOS &lt;- data.frame(DOI = myDOIs, WOS = vecWOS) write.csv(dfDOIWOS, file = &quot;dfDOIWOS.csv&quot;, row.names = FALSE) Le résultat est le suivant (non exécuté car la procédure d’interrogation avec la fonction GET() est très lente : si nous souhaitons travailler sur un liste de plusieurs dizaines ou centaines d’articles, plusieurs heures seront nécessaires avant d’obtenir le résultat). # DOI WOS # 1 10.1111/2041-210X.12935 000429421800031 # 2 10.1007/s13355-017-0480-5 000400381400016 Voici le code complet : pkgCheck &lt;- function(packages){ for(x in packages){ try(if (!require(x, character.only = TRUE)){ install.packages(x, dependencies = TRUE) if(!require(x, character.only = TRUE)) { stop() } }) } } pkgCheck(&quot;httr&quot;) myDOIs &lt;- c(&quot;10.1111/2041-210X.12935&quot;, &quot;10.1007/s13355-017-0480-5&quot;) vecWOS &lt;- vector() for(i in seq_along(myDOIs)){ myDOI &lt;- myDOIs[i] myWebPage &lt;- paste0( &quot;http://ws.isiknowledge.com/&quot;, &quot;cps/openurl/service?url_ver=Z39.88-2004&quot;, &quot;&amp;rft_id=info:doi/&quot;, myDOI) r &lt;- GET(myWebPage) urlWOS &lt;- r[[1]] tryExtract &lt;- &quot;&quot; try(tryExtract &lt;- substr(x = urlWOS, start = 117, stop = 131), silent = TRUE) if(!grepl(pattern = &#39;^[0-9]*$&#39;, x = tryExtract)){tryExtract &lt;- &quot;&quot;} vecWOS &lt;- append(vecWOS, tryExtract) } dfDOIWOS &lt;- data.frame(DOI = myDOIs, WOS = vecWOS) write.csv(dfDOIWOS, file = &quot;dfDOIWOS.csv&quot;, row.names = FALSE) La boucle for() pourrait être remplacée par une boucle sapply() pour gagner en temps d’exécution. Un gain serait également possible en effectuant une parallélisation sur cette boucle. Pour information, voici un exemple de temps d’exécution renvoyé par la fonction system.time() et microbenchmark::microbenchmark() : # system.time() # user system elapsed # 0.10 0.01 35.00 # microbenchmark() # Unit: seconds # expr min lq mean median uq max neval # myFun() 36.58966 36.58966 36.58966 36.58966 36.58966 36.58966 1 Nous venons de faire un script qui permet à partir d’une liste de numéros DOI d’obtenir automatiquement les numéros WOS. "]
]
