# (PART) Annexes {-}

# Manipuler des dates et des heures {#studyCase001}

Dans les études de biologie, d'écologie ou d'agronomie, nous utilisons fréquemment des données de température provenant de dataloggers. Dans cette étude de cas, nous verrons comment analyser ces données en utilisant les données de température de l'altiplano bolivien près de la ville de El Alto. La première étape consiste à transformer les données du datalogger en un format facile à lire pour R. Nous utiliserons un fichier CSV et la fonction [`read.table()`](#import). Le fichier peut être téléchargé à partir du site Web du livre sur GitHub (https://github.com/frareb/myRBook_FR/blob/master/myFiles/E05C13.csv), ou alors lu directement par R depuis sa source (https://raw.githubusercontent.com/frareb/myRBook_FR/master/myFiles/E05C13.csv).

```{r 041-studyCase-1, linewidth=65}
# Lecture du fichier en local après téléchargement : 
bdd <- read.table(
  "myFiles/E05C13.csv", 
  skip = 1, header = TRUE, 
  sep = ",", dec = ".", 
  stringsAsFactors = FALSE)
# Lecture du fichier depuis GitHub : 
# URL <- paste0("https://raw.githubusercontent.com/",
#   "frareb/myRBook_FR/master/myFiles/E05C13.csv")
# bdd <- read.table(
#   URL, 
#   skip = 1, 
#   header = TRUE,
#   sep = ",",
#   dec = ".",
#   stringsAsFactors = FALSE)
colnames(bdd) <- c("id", "date", "temp")
head(bdd)
tail(bdd)
str(bdd)
```

Nous pouvons voir que la date est au format `character` et qu'elle contient la date avec le mois, le jour et l'année séparés par `/`, puis vient un espace et l'heure avec des heures de 0 à 24, minutes et secondes, séparés par `:` (exemple: `11/12/15 23:00:00` pour le 12 novembre 2015 à 11 heures du soir). Nous allons séparer les informations en plusieurs objets. Séparons d'abord la date de l'heure. Pour cela, nous utiliserons la fonction `strsplit()` en utilisant l’espace entre la date et l’heure comme séparateur.

```{r 041-studyCase-2}
strsplit("11/12/15 23:00:00", split = " ")
```

Comme l'indiquent les doubles crochets, la fonction `strsplit()` renvoie un objet au format `list`. Nous voulons le vecteur qui correspond au premier élément de la liste, donc nous allons ajouter `[[1]]`.

```{r 041-studyCase-3}
strsplit("11/12/15 23:00:00", split = " ")[[1]]
```

Le premier élément du `vector` est la date. Pour avoir toutes les dates, nous allons faire une boucle avec la fonction `sapply()`.

```{r 041-studyCase-4}
bddDay <- sapply(
  strsplit(
    bdd[, 2], 
    split = " "), 
  "[[", 1)
head(bddDay)
```

Ensuite, nous aurons besoin des dates dans le format `Date`. pour cela nous allons transformer l'objet au format `Date` avec la fonction `as.Date()`. 

```{r 041-studyCase-5}
bddDay <- as.Date(
  sapply(
    strsplit(
      bdd[, 2], 
      split = " "), 
    "[[", 1), 
  format = "%m/%d/%y")
head(bddDay)
```

Nous allons maintenant ajouter l'objet `bddDay` à notre `data.frame` `bdd`. Ensuite, nous allons vérifier que cette nouvelle colonne dans notre `data.frame` est bien au format `Date` avec la fonction `str()`

```{r 041-studyCase-6, linewidth=65}
bdd$day <- bddDay
str(bdd)
```

Si l'information concernant la date n'est pas suffisante, nous pouvons ajouter l'heure. Dans ce cas c'est le format `POSIX` qu'il faudra utiliser avec la fonction `as.POSIXct()`. De la même manière nous allons ajouter l'information dans notre objet `bdd` et vérifier le format avec la fonction `str()`.

```{r 041-studyCase-7, linewidth=65}
bddPosix <- as.POSIXct(
  bdd$date, 
  format = "%m/%d/%y %H:%M:%S")
head(bddPosix)
bdd$posix <- bddPosix
str(bdd)
```

Dans les fonctions `as.Date()` et `as.POSIXct()`, nous avons utilisé l'argument `format` qui correspond au format dans lequel l'information sur la date est codée. Voici les éléments les plus courants pour le formatage de la date :

| code | Valeur |
|--------|-------|
|%a|jour de la semaine (abréviation)|
|%A|jour de la semaine|
|%b|mois (abréviation)|
|%B|mois|
|%d|jour du mois (decimal)|
|%j|jour de l'année (decimal)|
|%m|mois (decimal)|
|%y|année avec deux chiffres|
|%Y|année|
|%U|semaine de l'année en commençant par dimanche (decimal)|
|%W|semaine de l'année en commençant par lundi (decimal)|
|%H|heure 24|
|%I|heure 12|
|%M|minute|
|%S|seconde|

Nous pouvons visualiser les données avec la fonction `plot()` (Figure \@ref(fig:041-studyCase-8)).

```{r 041-studyCase-8, fig.width=10, fig.height=6, out.width = '90%', fig.cap="Données brutes d'une série temporelle"}
par(mar = c(4, 4, 1, 1)) # réduction des marges
plot(x = bdd$day, y = bdd$temp, 
  type = 'l', ylim = c(-15, 40), 
  xlab = "Temps", ylab = "Température (°C)")
```

Nous pouvons simplifier les informations en ne calculant que les températures minimales, moyennes et maximales par jour avec la fonction `tapply()` (Figure \@ref(fig:041-studyCase-9)). 

```{r 041-studyCase-9, fig.width=10, fig.height=6, out.width = '90%', fig.cap="Données agrégées par jour ; voir cahier en couleurs"}
tempDayMean <- tapply(bdd$temp, INDEX = bdd$day, FUN = mean)
tempDayMin <- tapply(bdd$temp, INDEX = bdd$day, FUN = min)
tempDayMax <- tapply(bdd$temp, INDEX = bdd$day, FUN = max)
par(mar = c(4, 4, 1, 1))
plot(x = as.Date(names(tempDayMean), format = "%Y-%m-%d"), 
  y = tempDayMean, type = 'l', ylim = c(-15, 40), 
  xlab = "Temps", ylab = "Température (°C)", lwd = 2)
points(as.Date(names(tempDayMin), format = "%Y-%m-%d"), 
  y = tempDayMin, type = 'l', col = 4, lwd = 2)
points(as.Date(names(tempDayMax), format = "%Y-%m-%d"), 
  y = tempDayMax, type = 'l', col = 2, lwd = 2)
legend("topright", legend = c("min", "max", "mean"), 
  lty = 1, lwd = 2, col = c(4, 2, 1))
```

Nous pouvons très facilement représenter la même information par semaine. Il suffit de changer l'argument `INDEX` pour la semaine. Voici un exemple de format par semaine (Figure \@ref(fig:041-studyCase-11)) :

```{r 041-studyCase-10}
anoSem <- format(bdd$posix, format = "%Y-%W")
head(anoSem)
```

```{r 041-studyCase-11, fig.width=10, fig.height=6, out.width = '90%', fig.cap="Données agrégées par semaine ; voir cahier en couleurs"}
tempWeekMean <- tapply(bdd$temp, 
  INDEX = format(bdd$posix, format = "%Y-%W-1"), FUN = mean)
tempWeekMin <- tapply(bdd$temp, 
  INDEX = format(bdd$posix, format = "%Y-%W-1"), FUN = min)
tempWeekMax <- tapply(bdd$temp, 
  INDEX = format(bdd$posix, format = "%Y-%W-1"), FUN = max)
par(mar = c(4, 4, 1, 1)) # réduction des marges
plot(x = as.Date(names(tempWeekMean), format = "%Y-%W-%u"), 
    y = tempWeekMean, type = 'l', ylim = c(-15, 40), 
    xlab = "Date", ylab = "Temperature (°C)", lwd = 3)
points(x = as.Date(names(tempWeekMin), format = "%Y-%W-%u"), 
    y = tempWeekMin, type = 'l', col = 4, lwd = 3)
points(x = as.Date(names(tempWeekMax), format = "%Y-%W-%u"), 
    y = tempWeekMax, type = 'l', col = 2, lwd = 3)
legend("topright", legend = c("min", "max", "mean"), 
  lty = 1, lwd = 2, col = c(4, 2, 1))
```

Dans ce type de représentation nous perdons l'information sur la variabilité des températures au sein d'une semaine. En fonction des objectifs, il pourra être intéressant de préférer une représentation sous forme de `boxplot` (ici un boxplot par mois en formatant la date avec `"%Y-%m"` ; Figure \@ref(fig:041-studyCase-12)). Nous pourrons noter que le code est plus simple grâce à l'usage de `~` qui peut être traduit par "en fonction de" (`bdd$temp ~ format(bdd$posix, format = "%Y-%m")` correspond donc à la température en fonction de la date au format POSIX reformatée pour ne faire apparaître que l'année et le mois).

```{r 041-studyCase-12, fig.width=10, fig.height=6, out.width = '90%', fig.cap="Données agrégées par mois"}
par(mar = c(5, 4, 0, 0))
boxplot(
  bdd$temp ~ format(bdd$posix, format = "%Y-%m"), 
  las = 3,
  xlab = "", ylab = "Température (°C)")
```

Pour comparer les différentes valeurs de température, il peut être utile d'attribuer une couleur à chaque boxplot. Par exemple, nous pouvons utiliser un gradient de couleurs du bleu au rouge en utilisant la valeur moyenne de la température (Figure \@ref(fig:041-studyCase-13)).

```{r 041-studyCase-13, fig.width=10, fig.height=6, out.width = '90%', fig.cap="Données agrégées par mois ; voir cahier en couleurs"}
tempMonthMean <- tapply(bdd$temp, 
  INDEX = format(bdd$posix, format = "%Y-%m"), FUN = mean)
myCol <- colorRampPalette(c("blue", "red"))(101)
tempMeanDayPos <- round(
  (tempMonthMean - min(tempMonthMean)) / 
    (max(tempMonthMean) - min(tempMonthMean))*100) + 1
par(mar = c(5, 4, 0, 0)) 
boxplot(
  bdd$temp ~ format(bdd$posix, format = "%Y-%m"), 
  las = 3, 
  col = myCol[tempMeanDayPos],
  xlab = "", ylab = "Température (°C)")
```

Après avoir calculé la température moyenne par mois (`tempMonthMean`), nous avons créé une palette de 101 valeurs du bleu au rouge avec la fonction `colorRampPalette()`. Ensuite nous avons transformé la température moyenne pour lui donner une valeur entre 1 et 101 stockée dans la variable `tempMeanDayPos`. Le boxplot prend ensuite la couleur correspondante à l'index de la température transformée (`col = myCol[tempMeanDayPos]`).

Et pour celles et ceux qui utilisent `ggplot2` (Figure \@ref(fig:041-studyCase-14)) :

```{r 041-studyCase-14, fig.width=10, fig.height=6, out.width = '90%', fig.cap="Données agrégées par mois ; voir cahier en couleurs"}
pkgCheck <- function(x){ 
    if (!require(x, character.only = TRUE)){
        install.packages(x, dependencies = TRUE)
        if(!require(x, character.only = TRUE)) {
            stop()
        }
    }
}
pkgCheck("ggplot2")

tempMonthMean <- tapply(bdd$temp, 
  INDEX = format(bdd$posix, format = "%Y-%m"), FUN = mean)
myCol <- colorRampPalette(c("blue", "red"))(101)
tempMeanDayPos <- round(
  (tempMonthMean - min(tempMonthMean)) / 
    (max(tempMonthMean) - min(tempMonthMean))*100) + 1
p01 <- ggplot(data = bdd, 
  aes(
    x = posix, 
    y = temp, 
    group = format(posix, format = "%Y-%m"))) + 
    geom_boxplot(
      outlier.colour = "black", 
      fill = myCol[tempMeanDayPos])
p01
```

Nous pouvons également calculer la différence entre la température maximale et la température minimale (variation de la température par jour ; Figure \@ref(fig:041-studyCase-15)).

```{r 041-studyCase-15, fig.width=10, fig.height=6, out.width = '100%', fig.cap="Variation de la température par jour"}
tempDayTR <- tempDayMax - tempDayMin
par(mar = c(4, 4, 1, 1)) # réduction des marges
plot(
  x = as.Date(names(tempDayMean), format = "%Y-%m-%d"), 
  y = tempDayTR, type = 'l', ylim = c(5, 45), 
  xlab = "Date", 
  ylab = "Variation de température diurne (°C)", 
  lwd = 3)
```

Une autre possibilité est de regrouper les données pour avoir la température moyenne des heures de la journée avec la fonction `aggregate()` (Figure \@ref(fig:041-studyCase-16)).

```{r 041-studyCase-16, fig.width=10, fig.height=6, out.width = '100%', fig.cap="Données agrégées par heure ; voir cahier en couleurs"}
tempHourMean <- aggregate(
  x = bdd$temp, 
  by = list(format(bdd$posix, format = "%H:%M")), 
  FUN = mean)
tempHourMin <- aggregate(
  x = bdd$temp, 
  by = list(format(bdd$posix, format = "%H:%M")), 
  FUN = min)
tempHourMax <- aggregate(
  x = bdd$temp, 
  by = list(format(bdd$posix, format = "%H:%M")), 
  FUN = max)
hours <- seq(from = 0, to = 23.5, by = 0.5)
par(mar = c(4, 4, 1, 1)) # réduction des marges
plot(x = hours, 
  y = tempHourMean[, 2], type = 'l', ylim = c(-15, 40), 
  xlab = "", ylab = "Température (°C)", lwd = 2, 
  xaxt = "n", panel.first = {
    abline(v = hours, col = "gray", lty = 2)
    abline(h = 0, lty = 2)  
  })
axis(
  side = 1, 
  at = hours, 
  labels = tempHourMean[, 1], 
  las = 2)
points(
  x = hours, 
  y = tempHourMin[, 2], 
  type = 'l', col = 4, lwd = 2)
points(
  x = hours, 
  y = tempHourMax[, 2], 
  type = 'l', col = 2, lwd = 2)
```

Nous pouvons également calculer les températures des heures de la journée pour chaque mois (Figure \@ref(fig:041-studyCase-17)).

```{r 041-studyCase-17, fig.width=10, fig.height=6, out.width = '100%', fig.cap="Données agrégées par heure et par mois ; voir cahier en couleurs"}
meses <- c("Janvier", "Février", "Mars", "Avril", "Mai", 
  "Juin", "Juillet", "Août", "Septembre", "Octobre", 
  "Novembre", "Décembre")
hours <- seq(from = 0, to = 23.5, by = 0.5)
bddMonth <- format(bdd$day, format = "%m")
tempDayEachMonth <- lapply(
  sort(unique(bddMonth)), function(myMonth){
    bddX <- bdd[bddMonth == myMonth, ]
    tempHourMean <- aggregate(
      x = bddX$temp, 
      by = list(format(bddX$posix, format = "%H:%M")), 
      FUN = mean)
    tempHourMin <- aggregate(
      x = bddX$temp, 
      by = list(format(bddX$posix, format = "%H:%M")), 
      FUN = min)
    tempHourMax <- aggregate(
      x = bddX$temp, 
      by = list(format(bddX$posix, format = "%H:%M")), 
      FUN = max)
  return(
    data.frame(
      tempHourMean, 
      tempHourMin, 
      tempHourMax))
})
par(mar = c(4, 4, 1, 1)) 
# for (i in seq_along(tempDayEachMonth)){ # pour tous les mois
i <- 1 # uniquement Janvier 
  plot(x = hours, y = tempDayEachMonth[[i]][, 2], 
    type = 'l', ylim = c(-15, 40), 
    xlab = "", ylab = "Température (°C)", lwd = 2, 
    main = meses[i],
    xaxt = "n", panel.first = {
      abline(v = hours, col = "gray", lty = 2)
      abline(h = 0, lty = 2)  
    })
  axis(
    side = 1, 
    at = hours, 
    labels = tempHourMean[, 1], 
    las = 2)
  points(
    x = hours, 
    y = tempDayEachMonth[[i]][, 4], 
    type = 'l', col = 4, lwd = 2)
  points(
    x = hours, 
    y = tempDayEachMonth[[i]][, 6], 
    type = 'l', col = 2, lwd = 2)
# }
```

Ou les regrouper dans un même graphique, ainsi que la variation diurne des températures pour chaque mois (Figures \@ref(fig:041-studyCase-18) et \@ref(fig:041-studyCase-18b)).

```{r 041-studyCase-18, fig.width=10, fig.height=6, out.width = '100%', fig.cap="Température par heure et par mois ; voir cahier en couleurs"}
par(mar = c(4, 4, 1, 1)) # réduction des marges
plot(
  x = hours, 
  y = tempDayEachMonth[[1]][, 2], 
  type = 'n', 
  ylim = c(-10, 35),
  xlab = "", 
  ylab = "Température moyenne (°C)",
  xaxt = "n", 
  panel.first = {
    abline(v = hours, col = "gray", lty = 2)
    abline(h = 0, lty = 2)  
  })
axis(
  side = 1, 
  at = hours, 
  labels = tempHourMean[, 1], 
  las = 2)
myColors <- c("#A6CEE3", "#1F78B4", "#B2DF8A", "#33A02C", 
  "#FB9A99", "#E31A1C", "#FDBF6F", "#FF7F00", "#CAB2D6", 
  "#6A3D9A", "#FFFF99", "#B15928")
for (i in seq_along(tempDayEachMonth)){
  points(x = hours, 
    y = tempDayEachMonth[[i]][, 2], 
    type = 'l', col = myColors[i], lwd = 2)
}
legend(
  "topright", 
  ncol = 4, 
  legend = meses, 
  col = myColors, 
  lty = 1, lwd = 2, 
  cex = 0.8, bg = "white")
```

```{r 041-studyCase-18b, fig.width=10, fig.height=6, out.width = '100%', fig.cap="Variations de température par mois ; voir cahier en couleurs"}
par(mar = c(4, 4, 1, 1)) # réduction des marges
plot(
  x = hours, 
  y = tempDayEachMonth[[1]][, 2], 
  type = 'n', 
  ylim = c(0, 30),
  xlab = "", 
  ylab = "Variation de température diurne (°C)",
  xaxt = "n", 
  panel.first = {
    abline(v = hours, col = "gray", lty = 2)
    abline(h = 0, lty = 2)  
  })
axis(
  side = 1, 
  at = hours, 
  labels = tempHourMean[, 1], 
  las = 2)
myColors <- c("#A6CEE3", "#1F78B4", "#B2DF8A", "#33A02C", 
  "#FB9A99", "#E31A1C", "#FDBF6F", "#FF7F00", "#CAB2D6", 
  "#6A3D9A", "#FFFF99", "#B15928")
for (i in seq_along(tempDayEachMonth)){
  points(
    x = hours, 
    y = tempDayEachMonth[[i]][, 6] - 
      tempDayEachMonth[[i]][, 4], 
    type = 'l', 
    col = myColors[i], 
    lwd = 2)
}
legend(
  "topright", 
  ncol = 4, 
  legend = meses, 
  col = myColors,
  lty = 1, lwd = 2, 
  cex = 0.8, bg = "white")
```

Nous pouvons aussi représenter les températures journalières avec des graphiques de type "ridgeline" et le package `ggplot2` (https://www.data-to-viz.com/graph/ridgeline.html ; Figure \@ref(fig:041-studyCase-19)).

```{r 041-studyCase-19, fig.width=10, fig.height=6, fig.cap="Graphique de type ridgeline ; voir cahier en couleurs"}
pkgCheck <- function(x){ 
  if (!require(x, character.only = TRUE)){
    install.packages(x, dependencies = TRUE)
    if(!require(x, character.only = TRUE)) {
      stop()
    }
  }
}
pkgCheck("ggplot2")
pkgCheck("ggridges")
pkgCheck("viridis")
meanTemps <- unlist(lapply(tempDayEachMonth, "[[", 2))
labelMonth <- rep(meses, each = 48)
dfTemps <- data.frame(month = labelMonth, value = meanTemps, 
  stringsAsFactors = FALSE)
dfTemps$month <- factor(dfTemps$month, levels = rev(meses))
p <- ggplot(
  data = dfTemps, 
  aes(y = month, x = value,  fill = ..x..))
p <- p + geom_density_ridges_gradient(stat = "binline")
p <- p + scale_fill_viridis(
  name = "Temp. [°C]", option = "C")
p <- p + xlab("Temperature") + ylab("") +
    theme(
      legend.position="none",
      panel.spacing = unit(0.1, "lines"),
      strip.text.x = element_text(size = 8)
    ) 
p
```

